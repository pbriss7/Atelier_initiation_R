---
title: "Atelier 5 : filtrer les données d'un tableau"
author: "Pascal Brissette (U. McGill)"
date: 13 septembre 2022
format: pdf
editor: visual
---

![Image libre de droit (Pixabay)](images/water-ga752c3e99_1280.png){fig-align="center" width="209"}

Dans cet atelier, vous apprendrez à filtrer des tableaux de données, c'est-à-dire à extraire d'un tableau un sous-ensemble de données. Vous avez déjà fait un tel type d'opération dans l'atelier précédent. Vous avez vu que nous pouvions utiliser les opérateurs d'indiçage (`[ , ]` et `$`) pour isoler ou extraire une ou pluseurs lignes ou colonnes d'un tableau, voire la modalité d'une seule cellule. Dans les crochets `[ i , j ]`, on place en position `i` un vecteur indiquant quelle(s) ligne(s) nous souhaitons extraire; en position `j`, nous faisons de même pour les colonnes d'intérêt.

Je suggère que nous nous pratiquions à nouveau à extraire quelques sous-ensembles de données du tableau construit dans le dernier atelier. S'il n'est pas déjà dans votre environnement de travail, nous allons l'y importer.

```{r}
if(!"ouvrages" %in% ls()) {ouvrages <- readRDS("donnees/ouvrages.RDS")}
str(ouvrages)

# On extrait les lignes 2 à 4 et les colonnes 3 à 5
ouvrages[2:4, 3:5]

# On extrait les lignes 1, 3 et 5, ainsi que les colonnes 3 et 5
ouvrages[c(1,3,5), c(3,5)]

# On extrait toutes les lignes et uniquement les colonnes "auteur.trice" et "annee.publication"
ouvrages[ , c("auteur.trice", "annee.publication")]
```

Pour isoler des sous-ensembles de données du tableau `ouvrages`, nous avons utilisé ci-dessus des vecteurs numériques et des vecteurs de caractères. Nous aurions aussi pu utiliser, dans les arguments de l'indiçage, des vecteurs de type logique, `TRUE`, `FALSE`. Le tableau est composé de huit lignes et de cinq colonnes. Pour chacune des lignes et des colonnes, nous allons utiliser `TRUE` si nous souhaitons l'extraire et `FALSE` dans le cas contraire.

```{r}
ouvrages[c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE), c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE)]
```

Cette façon de faire ne semble pas très efficace *a priori*, mais vous verrez qu'elle constituera un atout dans le filtrage des données par condition.

En effet, si l'indiçage se fait à l'aide de vecteurs, cela veut dire dire qu'on pourrait utiliser en guise d'arguments d'indiçage, pour un tableau donné, des opérateurs ou des fonctions qui retournent des vecteurs. Cela peut paraître abstrait et le mieux est sans doute de passer par l'exemple.

## Isoler des données avec les opérateurs `==`, `>` et `<`

Prenons d'abord un opérateur de base, `==`. Il ne faut pas le confondre avec l'opérateur déjà vu, `=`. Ce dernier en est un d'assignation et permet par exemple de définir des arguments dans une fonction. L'opérateur `==` sert à vérifier l'égalité entre deux éléments et il renvoit une donnée de type logique, `TRUE` si les deux éléments comparés sont identiques, ou `FALSE` s'ils sont différents. Sachant cela, on peut demander à R de filtrer le tableau en fonction d'une date ou d'un nom d'auteur, ou encore d'un titre:

```{r}
ouvrages[ouvrages$annee.publication == 1892,]
ouvrages[ouvrages$auteur.trice == "Lamartine",]
ouvrages[ouvrages$oeuvre == "Corinne",]
```

Que vient-il de se passer? Nous avons mis en position d'indiçage `i` du tableau `ouvrages`, à la gauche de l'opérateur `==`, un vecteur de ce tableau, soit la colonne `annee.publication`, puis avons indiqué, de l'autre côté de l'opérateur `==` une date, soit le nombre entier `1892`. R va donc passer en revue tous les éléments de cette colonne spécifique et renvoyer à la fonction d'indiçage `TRUE` si la date trouvée correspond au nombre entier indiqué en `i` et `FALSE` dans le cas contraire. Il se trouve ainsi à faire automatiquement l'opération que nous avons faite plus haut en insérant manuellement `TRUE` ou `FALSE` dans un vecteur d'indiçage.

On pourrait également utiliser les opérateurs de grandeur `<` et `>` pour filtrer les ouvrages dont la date de publication est plus grande que, disons, 1840 (condition simple), ou encore les ouvrages dont la date de publication se situe entre 1750 et 1830 (double condition).

```{r}
ouvrages[ouvrages$annee.publication > 1840,]

ouvrages[ouvrages$annee.publication > 1750 & ouvrages$annee.publication < 1830,]
```

À nouveau, R filtre les lignes en fonction d'une condition appliquée au vecteur `annee.publication`, qui est une colonne du tableau `rc`. Il vérifie, pour chaque ligne du tableau, si la valeur indiquée au croisement de la ligne et de la colonne `annee.publication` est plus grande que 1840. Le cas échéant, il considère que la réponse à la question `ouvrages$annee.publication > 1840` est `TRUE` et il extrait la ligne. La deuxième instruction suit le même principe: R évalue, pour chaque ligne, si la valeur entrée dans la colonne `annee.publication` est plus grande que 1750 et (opérateur `&`) plus petite que 1830. Le cas échéant, il considère que la réponse à la question `ouvrages$annee.publication > 1840` est `TRUE` et il extrait la ligne.

Importons dans l'environnement de RStudio un "vrai" jeu de données provenant de Données Québec. Ce [jeu de données](https://www.donneesquebec.ca/recherche/dataset/longs-metrages-diffuses-a-radio-canada) "répertorie les diffusions de longs métrages, tous genres confondus, à Radio-Canada, durant la décennie 2010".

```{r}

rc <- read.csv("donnees/rc_longs_metrages.csv", header = TRUE)

```

Le tableau de données importé comporte 5 045 lignes et 14 colonnes. Ce ne serait pas une bonne idée d'imprimer ce tableau dans la console. D'une part, vous risqueriez de saturer la mémoire de RStudio et de geler le programme. D'autre part, peu importe ce que vous cherchez exactement dans votre tableau, R le trouvera beaucoup mieux et plus rapidement que vous, si vous lui donnez les bonnes instructions.

## Isoler un sous-ensemble de lignes avec la fonction `grep()`

Supposons que vous souhaitiez consulter tous les titres de longs-métrages diffusés sur Radio-Canada entre 2010 et 2020 contenant le mot "femme". La colonne `TITRE_FRANÇAIS` de notre tableau, formé d'un long vecteur comprenant autant d'éléments qu'il y a de lignes dans le tableau, est le lieu où faire cette recherche. Dans une situation comme celle-ci, vous ne pourriez simplement utiliser l'opérateur d'identité introduit ci-dessus (`==`), parce que le mot "femme" n'est potentiellement qu'un segment des titres de longs-métrages. Si vous utilisez cet opérateur, par exemple comme dans l'exemple ci-dessous, vous n'obtiendrez que les lignes dont le `TITRE_FRANÇAIS` est exactement "femme". Essayons:

```{r}
rc[rc$TITRE_FRANÇAIS == "femme",]
```

Aucun titre ne correspond exactement à cette seule chaîne de caractère. Est-ce à dire qu'aucun titre ne contient le mot "femme"? Pour le savoir, on peut recourir à la fonction `grep()` de l'extension de base, qui prend en entrée un vecteur composé de chaînes de caractères (pour nous, ce sera la colonne `TITRE_FRANÇAIS`). La fonction `grep()` cherche des motifs, des *patterns*, dans les chaînes de caractères. Son premier argument est justement `pattern=` et son second, un vecteur de caractères où effectuer la recherche, `x=`. Offrons donc à la fonction, en guise de *pattern*, le mot "femme". Observez le résultat de l'opération, ce que renvoit la fonction.

```{r}
# On isole la colonne avec l'opérateur `$`, comme on a appris à le faire dans le dernier atelier
grep(pattern = "femme", x = rc$TITRE_FRANÇAIS)

```

À quoi ces nombres entiers correspondent-ils selon vous?

Réponse: aux positions des éléments du vecteur `rc$TITRE_FRANÇAIS` où la fonction `grep()` a trouvé la chaîne de caractères "femme". Cette suite de nombres forme un vecteur et, comme ce vecteur correspond à une colonne dans le tableau de données `rc`, cela veut dire que ces nombres sont aussi des numéros de lignes du tableau dont `rc$TITRE_FRANÇAIS` forme une colonne.

Vous souhaitez en avoir la preuve? Voyons:

```{r}

# On crée un vecteur numérique avec la fonction `grep()`
nos_lignes <- grep("femme", rc$TITRE_FRANÇAIS)

is.vector(nos_lignes)
is.integer(nos_lignes)

# On filtre le tableau de données avec ce vecteur:
rc[nos_lignes, c("TITRE_ORIGINAL", "TITRE_FRANÇAIS")]

```

## Isoler un sous-ensemble de colonnes avec la fonction `grep()`

La même opération peut être faite sur les noms de colonnes. Vous n'auriez sans doute pas à faire une telle opération avec un tableau ne comportant que 14 colonnes, mais vous aurez bientôt à manipuler des tableaux de plusieurs centaines, voire de milliers de colonnes. Supposons donc, en guise d'exercice, que vous souhaitiez obtenir un sous-ensemble du tableau comprenant uniquement les données des colonnes dont le titre comporte les lettres "TITRE". Vous pourrez, comme on l'a fait ci-dessus, créer un vecteur numérique avec `grep()` puis insérer cet objet comme indice en position `j` des opérateurs d'indiçage, ou encore mettre dans cet espace la fonction elle-même et faire ainsi l'économie d'une étape.

```{r}
# Le vecteur où on souhaite faire la recherche est celui composé des noms de colonnes:
colnames(rc)

# C'est donc ce vecteur qu'on donnera à la fonction `grep()`, elle-même insérée en position `j` des crochets. 
rc[1, grep("TITRE", colnames(rc))]
```

Nous pouvons enfin combiner les deux opérations pour isoler un sous-ensemble de données correspondant à différentes conditions.

```{r}

# C'est donc ce vecteur qu'on donnera à la fonction `grep()`, elle-même insérée en position `j` des crochets. 
rc[grep(pattern = "femme", rc$TITRE_FRANÇAIS), grep("TITRE", colnames(rc))]
```

Vous verrez dans d'autres ateliers de nouveaux opérateurs et fonctions qui s'ajouteront à vos outils de filtrage.

## Ordonner les lignes d'un tableau avec la fonction `order()`.

Une autre fonction pratique, dans la manipulation des tableaux, est la fonction `order()`. Celle-ci prend un vecteur en entrée (donc une colonne d'un tableau) et ordonne les éléments du plus grand au plus petit ou, si l'argument `decreasing=TRUE`, du plus petit au plus grand. Ainsi, placé en position d'inçage *i* d'un tableau de données, cette fonction ordonnera toutes les lignes du tableau en question en fonction d'un vecteur ordonné. Si on voulait par exemple que le tableau `rc` soit ordonné selon la date de production des longs-métrages, de la date la plus lointaine vers la plus récente, on fournirait à R la commande suivante:

```{r}
head(rc[order(rc$ANNÉE_PRODUCTION),])
```

Appliqué à un vecteur de caractères, cette fonction ordonnerait le vecteur de la lettre "z" à la lettre "a", ou inversement si l'argument `decreasing=TRUE`.

## Les expressions régulières (regex)

La fonction `grep()` et de nombreuses autres fonctions très puissantes dans R utilisent des expressions régulières (ou *regex*, en anglais) pour saisir, dans des textes, des chaînes de caractères variées. Les expressions régulières sont utilisées dans d'autres contextes, notamment la programmation, mais elles nous intéressent en analyse de texte parce qu'elles font sauver temps et ressources. Nous avons, ci-dessus, utilisé le motif "femme" dans la fonction `grep()` et celle-ci a donc cherché à travers les différents éléments de la colonne `TITRE_FRANÇAIS` de l'objet `rc` cette suite précise de caractères. Dans les expressions régulières, les lettres (a, b, c...; A, B, C...) sont bel et bien des lettres, mais il existe plusieurs autres symboles et structures permettant d'étendre nos capacités de recherche. Par exemple, si nous souhaitons saisir toutes les lignes du tableau `rc` où apparaissaient à la fois les motifs "femme" et "Femme", nous pouvons le faire ou bien de cette manière:

```{r}
rc[c(grep(pattern = "femme", x = rc$TITRE_FRANÇAIS), grep(pattern = "Femme", x = rc$TITRE_FRANÇAIS)) , c("TITRE_ORIGINAL", "TITRE_FRANÇAIS")]
```

ou, de manière plus élégante et concise, avec l'expression régulière "\[Ff\]emme":

```{r}

rc[grep(pattern = "[Ff]emme", x = rc$TITRE_FRANÇAIS) , c("TITRE_ORIGINAL", "TITRE_FRANÇAIS")]

```

Si vous aviez souhaité exclure les cas de figure où le mot femme est écrit avec la marque du pluriel, vous auriez pu ajouter au motif "\[Ff\]emme" une balise de mot: "\[Ff\]emme\\\\b".

```{r}
rc[grep(pattern = "[Ff]emme\\b", x = rc$TITRE_FRANÇAIS) , c("TITRE_ORIGINAL", "TITRE_FRANÇAIS")]

```

Les expressions régulières sont pourvues de nombreux opérateurs et constructions, et il est facile de s'y perdre. Le mieux, une fois qu'on en a compris les principes, est de mettre en pratique quelques éléments clés dans des projets concrets et de faire des recherches sur les éléments qui nous sont inconnus.

Quelques "essentiels":

+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Expression | Explication                                                                                                                   | Éléments saisis et exemples                                                                                                                                                                                                                                     |
+============+===============================================================================================================================+=================================================================================================================================================================================================================================================================+
| `a, b, c…` | L'expression saisit la lettre ou le chiffre tel qu'il est exprimé.                                                            | "a", "b", "c",                                                                                                                                                                                                                                                  |
|            |                                                                                                                               |                                                                                                                                                                                                                                                                 |
| `A, B, C…` |                                                                                                                               | "A", "B", "C"                                                                                                                                                                                                                                                   |
|            |                                                                                                                               |                                                                                                                                                                                                                                                                 |
| `1, 2, 3`  |                                                                                                                               | "1", "2", "3"                                                                                                                                                                                                                                                   |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\b`      | Balise de mot                                                                                                                 | L'expression `jour` attrapera aussi bien le mot "jour" que "au**jour**d'hui", tandis que `\\bjour\\b`\` n'attrapera que le mot "jour" au singulier, tout en minuscules.                                                                                         |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\w`      | N'importe quel caractère d'un mot                                                                                             | `\\w+` saisira toutes les lettres d'un mot (un mot, ici, étant encadré de blancs typographiques ou de ponctuation)                                                                                                                                              |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\s`      | Une espace (simple ou tabulation)                                                                                             |                                                                                                                                                                                                                                                                 |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `.`        | N'importe quel caractère (lettre, chiffre, ponctuation, espace simple), une seule fois.                                       | `\\bMontr.al\\b` saisirait le mot "Montréal", "Montreal", mais également "Montrial", "Montr'al", "Montr al", etc..                                                                                                                                              |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\.`      | Un point, tout simplement. Les deux barres transversales inversées annulent la fonction spéciale accordée autrement au point. |                                                                                                                                                                                                                                                                 |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `?`        | L'élément qui précède immédiatement ce caractère est facultatif. Il s'agit d'un quantifieur.                                  | `\\bMontréalaise?\\b` saisirait aussi bien "Montréalais" que "Montréalaise". Le caractère `?` rend le "e" facultatif.                                                                                                                                           |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\?`      | Un point d'interrogation, tout simplement                                                                                     |                                                                                                                                                                                                                                                                 |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `+`        | L'élément qui précède doit être présent une ou plusieurs fois. Il s'agit d'un quantifieur.                                    | `Ah+` saisira "Ah", mais aussi "Ahh", "Ahhh", et ainsi de suite, jusqu'à ce que la fonction de recherche trouve un caractère autre que "h".                                                                                                                     |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\+`      | Un opérateur mathématique, tout simplement                                                                                    |                                                                                                                                                                                                                                                                 |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `^`        | Marque le début d'une chaîne de caractères (ce qui suit doit se trouver au tout début de la chaîne).                          | `^Femme` permettra d'attraper, dans le tableau `rc`, les titres **commençant** par le mot "Femme", avec la majuscule, mais non les titres ou le mot "Femme" apparaîtrait au milieu ou à la fin de la chaîne.                                                    |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `$`        | Marque la fin d'une chaîne de caractères (ce qui précède doit se trouver à la toute fin de la chaîne).                        | `femme$` saisira, dans le tableau `rc`, les titres qui se **terminent** par "femme" (sans la marque du pluriel: le "e" final de "femme" est immédiatement suivi du symbole `$`), mais nons ceux où le même mot apparaitrait au début ou au milieu de la chaîne. |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `[ ]`      | Tout caractère, ponctuation ou symbole qui se trouve à l'intérieur, y compris l'espace ou la tabulation, une seule fois.      | L'expression `Montr[ée]al` saisira à la fois "Montréal" et "Montreal".                                                                                                                                                                                          |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Vous trouverez ci-dessous une [antisèche (aide-mémoire) sur les expressions régulières](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) proposée par RStudio. Elle vous sera utile une fois que vous vous serez un peu familiarisé avec les expressions régulières. Le mieux est de trouver en ligne des ateliers qui vous permettront de vous pratiquer. Voyez par exemple le site [Data Carpentry](https://librarycarpentry.org/lc-data-intro/01-regular-expressions/). Les expressions régulières étant utilisées dans plusieurs langages de programmation et logiciels d'édition, les ressources pour en apprendre le maniement sont très nombreuses. En explorant cette documentation, gardez à l'esprit que, dans R, le caractère d'échappement `\` doit être doublé `\\`.

### [![Crédit: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf](images/regex.png)](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

## Défi

1.  À partir de la table `rc`, composez un sous-ensemble de données comprenant seulement les longs-métrages produits par la Grande-Bretagne (GB).
2.  Éliminez de ce sous-ensemble toutes les colonnes à l'exception de `TITRE_ORIGINAL`, `TITRE_FRANÇAIS`, `PAYS_1.`
3.  Quelle(s) fonctions pourrai(en)t vous renvoyer les dimensions de ce tableau de données? Exécutez-là et trouvez le nombre de lignes et de colonnes de ce sous-ensemble.
4.  Combien de films de ce sous-ensemble contiennent, dans `TITRE_FRANÇAIS`, le mot "homme" dans toutes ses déclinaisons ("Homme" et "homme" au singulier et au pluriel)?
