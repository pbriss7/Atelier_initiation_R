---
title: "Atelier 11: stringr"
author: "Pascal Brissette (U. McGill)"
date: 19 septembre 2022
format: pdf
editor: visual
---

L'extension `stringr` fait partie de la famille `tidyverse`, dont chaque extension répond à une philosophie de clarté et de cohérence, ainsi qu'à des règles d'enchaînement. Celle qui va nous intéresser dans cet atelier, `stringr`, offre une multitude de fonctions dédiées spécifiquement à la manipulation des chaines de caractères. Ces fonctions sont parfois des quasi copies de celles de base de R. Cependant, on entre dans `stringr` comme dans une maison bien rangée: les fonctions ont des noms simples et cohérents, les arguments sont présentés de manière uniforme d'une fonction à l'autre, et l'utilisation des expressions régulières est clairement expliquée dans les vignettes et dans l'antisèche distribuée par la société RStudio:

[![](images/antiseche_stringr.png){fig-align="center"}](https://www.rstudio.com/resources/cheatsheets/)

Dans `stringr`, toute fonction débute par `str_`, suivi d'un mot simple qui résume la tâche qu'elle peut accomplir: `str_detect()`, `str_match()`, `str_extract()`, `str_subset()`, etc. On ne fera pas la revue complète de ces fonctions, on en donnera simplement un aperçu. Vous pourrez bien entendu approfondir votre connaissance et votre maîtrise des fonctions en consultant la vignette proposée dans l'aide de RStudio (`??stringr`).

Pour illustrer l'utilité de `stringr`, nous allons importer le jeu de données sur les réalisatrices québécoises et leurs filmographies. Nous allons également installer, puis activer l'extension `stringr`.

```{r}
if(!"stringr" %in% rownames(installed.packages())) {install.packages("stringr")}
library(stringr)

filmo <- read.csv("donnees/filmographies_realisatrices_qc.tsv", sep = "\t", fileEncoding = "WINDOWS-1252")

```

### Fonctions d'indexation

#### `str_detect()` et `str_which()`

On a déjà eu l'occasion d'utiliser les fonctions de base `grep()` et `grepl()`, qui recourent à des expressions régulières et permettent de trouver des chaînes de caractères à l'aide de motifs (expressions régulières). La première de ces fonctions renvoie le numéro des éléments d'un vecteur où le motif a croisé l'élément recherché, l'autre retourne un long vecteur logique indiquant, élément après élément, si oui (`TRUE`) ou non (`FALSE`) la fonction a pu détecter la chaîne de caractères recherchée.

Il est facile de confondre les deux fonctions de base en raison de leur similitude. Dans `stringr`, celles-ci ont des noms plus évocateurs.

-   `str_detect()` est l'équivalent de `grepl()`: elle renverra un vecteur "logique" (composé de `TRUE` / `FALSE`) de même longueur que celui fourni en entrée. Pour chaque élément du vecteur d'entrée, la fonction placera, dans le vecteur de sortie, un booléen indiquant si oui ou non la fonction a trouvé les caractères recherchés.

-   `str_which()`, équivalent de `grep()`, ne renverra pour sa part que les numéros d'éléments (indices) du vecteur d'entrée où les caractères recherchés ont été trouvés au moins une fois.

Utilisons le jeu de données sur les réalisatrices québécoises pour illustrer le fonctionnement de cette première série de fonctions. Supposons que nous nous intéressions au thème de l'hiver dans le cinéma québécois et qu'on souhaite obtenir les titres de films contenant l'un ou l'autre des mots "hiver", "neige" et leurs équivalents anglais pour les films tournés en anglais ou traduits vers l'anglais. Nous utiliserons une expression régulière très simple: `\\bhiver\\b|\\bneige\\b|\\bwinter\\b|\\bsnow\\b`

```{r}
# Note: lorsqu'on exécute une ligne de code complètement comprise dans une parenthèse, comme ci-dessous, le résultat s'affiche automatiquement dans la console. Cette parenthèse supplémentaire est un raccourci pour la fonction print().

motif <- "(?i)\\bhiver\\b|\\bneige\\b|\\bwinter\\b|\\bsnow\\b"

# Repérage du motif avec str_which()
(
  which_hiver <- str_which(filmo$TITRE_ORIGINAL, pattern = motif, )
  )

# On voit que cinq films contiennent l'un ou l'autre de ces mots.


# Même recherche, mais avec avec str_detect() cette fois:
(
  detect_hiver <- str_detect(filmo$TITRE_ORIGINAL, pattern = "^Na")
  )

# Vous voyez que le résultat renvoyé est très différent: il s'agit d'un très long vecteur booléen où seuls 5 éléments seront TRUE.


# Enfin, on peut rechercher et extraire les éléments trouvés avec `str_extract()`

(
  extrac_hiver <- str_extract(filmo$TITRE_ORIGINAL, pattern = "^Na")
  )

# Le résultat est un vecteur de même longueur que celui d'entrée. Là où la chaine a été trouvée apparaît la chaine en question. Autrement, NA est renvoyé pour l'élément correspondant

# La fonction str_extract_all() renverra de son côté une liste de même longuer que le vecteur d'entrée
(
  extrac_hiver_all <- str_extract_all(filmo$TITRE_ORIGINAL, pattern = "^Na")
  )

# Lorsque la chaine n'a pas été trouvée, l'élément de la liste contient `character(0)`
```

Les exemples proposés et les résultats obtenus pourront vous laisser perplexe: à quoi peuvent bien servir des fonctions qui retournent des résultats aussi difficiles à visualiser? Nous allons, pour mieux illustrer leur utilité, les intégrer à une tâche commune.

Supposons que nous souhaitions enrichir le tableau avec une donnée catégorielle indiquant si le titre contient un terme lié à l'hiver. Nous allons créer une nouvelle colonne dans notre tableau et y indiquer si oui (TRUE) ou non (FALSE) un mot lié à l'hiver se trouve dans le titre:

```{r}

# Expression régulière
detect_hiver <- "(?i)\\bhiver\\b|\\bneige\\b|\\bwinter\\b|\\bsnow\\b"

# On crée une nouvelle colonne appelée THEME et on y place la résultat de la fonction str_extract()
filmo$HIVER <- str_detect(filmo$TITRE_ORIGINAL, detect_hiver)

# On peut visualiser les titres et mots extraits
filmo[!filmo$HIVER == FALSE, c("TITRE_ORIGINAL", "HIVER")]

# On peut également obtenir une table de fréquence
table(filmo$HIVER)
```

Si on a plus d'un thème à l'esprit, on pourrait créer une colonne `THEME` et y indiquer, selon le motif thématique repéré dans le titre, le nom du thème. Comment faire cela? La fonction `str_detect()` sera encore notre alliée, mais il va falloir utiliser des structures de contrôle introduites dans l'atelier 9. Nous allons construire une structure conditionnelle avec `if()` `else if()` et `else {}`. Si le thème de l'hiver est trouvé avec `str_detect()`, R inscrira "hiver" dans la colonne `THEME`; si ce motif n'est pas trouvé, R vérifiera s'il trouve le motif de l'été et, le cas échéant, inscrira "été" dans la colonne `THEME`. Enfin, si aucun des deux motifs n'est trouvé, il inscrira "autre". Et comme cette instruction conditionnelle doit être vérifiée pour chaque élément, nous allons en faire une fonction et passer celle-ci à `sapply()`.

```{r}

# Fonction renvoyant le nom d'un thème en fonction du motif détecté
trouver_theme_f <- function(x) {
  theme <- NULL
  detect_hiver <- "(?i)\\bhiver\\b|\\bneige\\b|\\bwinter\\b|\\bsnow\\b"
  detect_ete <- "(?i)('|un) |[cdm]es )étés?\\b|\\bcanicules?\\b|\\bsummer\\b|\\bheatwave\\b"
  if (str_detect(x, detect_hiver)) {
    theme <- "hiver"
  } else if (str_detect(x, detect_ete)) {
    theme <- "été"
  } else {
    theme <- "autre"
  }
  return(theme)
}

# Exécution de la fonction de manière itérative
filmo$THEME <- sapply(filmo$TITRE_ORIGINAL, trouver_theme_f)


# La même opération aurait pu être faite avec une boucle for():
# detect_hiver <- "(?i)\\bhiver\\b|\\bneige\\b|\\bwinter\\b|\\bsnow\\b"
# detect_ete <- "(?i)('|un) |[cdm]es )étés?\\b|\\bcanicules?\\b|\\bsummer\\b|\\bheatwave\\b"
# 
# for(i in 1:nrow(filmo)) {
#   if (str_detect(filmo$TITRE_ORIGINAL[i], detect_hiver)) {
#     filmo$THEME[i] <- "hiver"
#   } else if (str_detect(filmo$TITRE_ORIGINAL[i], detect_ete)) {
#     filmo$THEME[i] <- "été"
#   } else {
#     filmo$THEME[i] <- "autre"
#   }
# }

# On peut examiner le résultat avec table()
table(filmo$THEME)

# Et les titres correspondant aux deux thèmes d'intérêt
filmo[str_detect(filmo$THEME, "été|hiver"), c("TITRE_ORIGINAL")]
```

L'examen des titres révèle un faux positif ("Blanche Neige..."), mais cela est inévitable avec une méthode assez peu raffinée. On pourrait ajouter à l'expression régulière `detect_hiver` que la séquence "neige" ne doit pas être précédée de "blanche". Cela révèle l'importance de toujours examiner les résultats et de procéder par ajustements successifs.

### Fonctions de substitution

#### `str_replace()` et `str_replace_all()`

Les tâches de remplacement sont parmi les plus fréquentes que vous devrez accomplir dans votre carrière de manipulateur·trice de chaînes de caractères! Vous supprimerez des mots fonctionnels, vous mettrez en minuscules des textes complets, uniformiserez des séries de caractères et ainsi de suite. Dans votre arsenal de fouille, il vous faudra donc une fonction puissante et aisée à utiliser. Dans R, cette fonction de base est `gsub()`, mais on lui préférera ici `str_replace()` et `str_replace_all()`. La première de ces deux fonctions ne remplacera que le premier élément d'un vecteur trouvé à l'aide du motif. La deuxième remplacera tous les cas repérés, même s'il y en a plus d'un dans un élément du vecteur.

En guise d'exemple, nous allons créer une nouvelle colonne appelée ABBREV_NOM, dont les valeurs seront faites de l'assemblage du prénom et du nom de chacune des réalisatrices du tableau. Dans un deuxième temps, nous allons transformer chacun de ces noms complets en abréviations.

```{r}

# Cette première commande assemble, dans une nouvelle colonne appeléeé "ABBREV", le prénom et le nom de la réalisatrice, séparés par "|".
filmo$ABBREV_NOM <- paste(filmo$PRENOM_REALISATRICE, filmo$NOM_REALISATRICE, sep = "|")

# Cette deuxième commande remplace toute chaine d'une ou plusieurs lettres non majuscules en un simple point (".")
filmo$ABBREV_NOM <- str_replace_all(filmo$ABBREV_NOM, "[^A-ZÉÏÈÙÊÎ-]+", "\\.")

# View(filmo)
```

D'autres fonctions de substitution très pratiques (`str_to_lower()`, `str_to_upper()`, `str_to_title()`) n'ont pas à être expliquées ici. Elles sont faciles à comprendre et à utiliser, et vous pourrez rapidement les mettre en pratique dans vos projets.

### Fonctions d'extraction

#### `str_sub()`

Parmi les fonctions d’extraction de `stringr`, la première que nous allons explorer est `str_sub()`. Cette fonction permet d’extraire des séquences de caractères en tenant compte de la position des caractères dans une chaine donnée. Si j'indique à la fonction de commencer l'extraction à "1" (argument: `start = 1`) et de terminer l'extraction à 5 (argument: `end = 5`), la fonction extraira les 5 premiers caractères du vecteur.

Prenons par exemple l'incipit de *La recherche du temps perdu*.

```{r}
incipit_RTP <- "Longtemps je me suis couché de bonne heure."

str_sub(incipit_RTP, start = 1L, end = 5L)

```

Les cinq premiers caractères de l'incipit sont donc renvoyés.

Si, au lieu de donner à la fonction str_sub() une simple chaine, nous lui donnons un vecteur avec plusieurs éléments, il accomplira sa tâche sur chaque élément et renverra un vecteur de même longueur avec le résultat.

Prenons les quelques prénoms de réalisatrices, tirés de filmo\$PRENOM_REALISATRICE, pour illustrer cet aspect de `str_sub()`.

```{r}
# Isolons d'abord les prénoms des dix premières réalisatrices 
quelques_prenoms <- unique(filmo$PRENOM_REALISATRICE[1:50])

quelques_prenoms

# Maintenant, extrayons les trois premiers caractères de chacun des prénoms
str_sub(quelques_prenoms, start = 1, end = 2)
```

Ainsi, l'argument `start = 1` de `str_sub()` indique à la fonction qu'on veut extraire la chaîne à partir du premier caractère. Avec le deuxième argument, `end = 3`, on lui indique où arrêter l'extraction.

Cette fonction est très utile lorsqu'on veut, par exemple, forger des identifiants uniques dans une liste ou un tableau, pour chacune des observations ou des documents. On collera par exemple avec `paste()` les deux derniers chiffres de l'année avec les trois premières lettres du prénom et les trois premières lettres du titre de l'œuvre. Avec la fonction `str_sub()`, une tâche comme celle-là est très aisée à réaliser.

#### `str_extract()` et `str_extract_all()`

Les fonctions `str_extract()` et `str_extract_all()` permettent l'extraction de la chaîne de caractères représentée par l'expression régulière fournie à l'argument `pattern =`. Cette fonction n'est pas d'un grand intérêt si le motif inséré en guise d'expression régulière est simplement composé de lettres. Par exemple:

```{r}
str_extract_all(filmo$TITRE_ORIGINAL, "femme")
```

Mais avec des expressions régulières plus complexes, elles peuvent s'avérer de puissantes alliées. On voudrait savoir par exemple quels mots précèdent et suivent immédiatement le mot femme dans les titres:

```{r}
# Ne vous laissez pas intimider par l'expression régulière!

unlist(str_extract_all(filmo$TITRE_ORIGINAL, pattern = "([\\w-'’]+?\\s?)?\\b[Ff]emmes?(\\s?\\b[\\w-'’]+)?"))
```

### Fonctions de séparation

Parmi les fonctions que vous utiliserez fréquemment dans le cadre de l'analyse des données textuelles se trouve `strsplit()` ou sa version de l'extension `stringr`, `str_split()`. Celle-ci prend en entrée un vecteur et retournera une liste où chaque élément sera formé d'un vecteur comprenant les séquences de caractères qui ont été divisées par le motif indiqué dans la fonction. Prenons les six premiers titres de notre table et séparons les mots qui le composent en prenant l'espace, l'apostrophe et le tiret comme motif de séparation.

```{r}
str_split(filmo$TITRE_ORIGINAL[1:6], pattern = "[\\s'’-]")

```

Les éléments qui ont servi à séparer les mots ont disparu et chaque titre a été divisé en segments. On saisira l'intérêt d'une telle opération lorsqu'on fera des calculs statistiques à partir de vecteurs de caractères conséquents.

## Défi

### Détection d'une séquence spécifique
Utilisez la fonction `str_detect()` pour repérer tous les films dans lesquels le titre contient un des mots suivants : "amour", "love", ou "romance", dans le tableau `filmo`. Créez ensuite une colonne supplémentaire `ROMANCE` qui indique `TRUE` si le mot est trouvé et `FALSE` sinon.

```{r}
motif_romance <- "(?i)\\bamour\\b|\\blove\\b|\\bromance\\b"
# filmo$ROMANCE <- str_detect(***)
# table(filmo$ROMANCE)
```

### Remplacement de mots
Utilisez `str_replace_all()` pour remplacer tous les titres de films dans lesquels on trouve le mot "cinéma" ou "film" par le mot "œuvre". Affichez ensuite les titres modifiés.

```{r}
motif_film <- "(?i)\\bcinéma\\b|\\bfilm\\b"
# filmo$TITRE_MODIFIE <- str_replace_all(***)
# filmo$TITRE_MODIFIE
```

### Extraction de prénoms abrégés
Utilisez la fonction `str_sub()` pour extraire et afficher seulement les trois premières lettres des prénoms des réalisatrices dans la colonne `PRENOM_REALISATRICE` du tableau `filmo`. Créez une nouvelle colonne appelée `ABBREV_PRENOM`.

```{r}
# filmo$ABBREV_PRENOM <- str_sub(***)
# filmo$ABBREV_PRENOM
```

### Comptage d'occurrences de mots
Utilisez `str_count()` pour compter combien de fois les mots "hiver" ou "neige" apparaissent dans chaque titre de film du tableau `filmo`. Ajoutez une colonne `HIVER_OCCURENCES` qui contiendra ce nombre.

```{r}
motif_hiver <- "(?i)\\bhiver\\b|\\bneige\\b"
# filmo$HIVER_OCCURENCES <- str_count(***)
# filmo$HIVER_OCCURENCES
```

### Filtrage de données avec str_subset()
Utilisez la fonction `str_subset()` pour extraire uniquement les titres de films qui contiennent le mot "été", "canicule", ou "summer". Affichez les titres filtrés.

```{r}
motif_ete <- "(?i)\\bété\\b|\\bcanicule\\b|\\bsummer\\b"
# titres_ete <- str_subset(***)
# titres_ete
```





## Pour aller plus loin

Vignette, [`stringr`](https://stringr.tidyverse.org/)
