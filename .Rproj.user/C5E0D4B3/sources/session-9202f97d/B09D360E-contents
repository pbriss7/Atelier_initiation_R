---
title: "Atelier 14: les fonctions"
author: "Pascal Brissette (U. McGill)"
format: pdf
editor: visual
---

[![Image vectorielle libre de droits, Pixabay](images/gear-wheel-g4c97afd80_1280.png){fig-align="center"}](https://pixabay.com/fr/vectors/roue-dent%c3%a9e-%c3%a9quipement-rouages-dent-310906/)

On a dit déjà que les fonctions étaient dans R des objets qui, comme d'autres, pouvaient être créés de toutes pièces et modifiés. Les fonctions que vous avez utilisées jusqu'ici proviennent d'extensions conçues et construites par des programmeur·e·s avancé·e·s, mais rien ne vous empêche de créer vos propres fonctions, destinées à remplir des tâches spécifiques. Vous y êtes même fortement encouragé·e·s. Pourquoi?

Tout d'abord, parce qu'une fonction est réutilisable et peut donc être mobilisée n'importe quand, dans n'importe quel script, pour effectuer une tâche donnée. Il y a donc un gain de temps: vous n'avez pas à vous répéter. Ensuite, si vous devez constamment recycler des lignes de codes ici et là comme autant de pièces d'un puzzle pour effectuer une opération, le fait d'assembler ces pièces en une fonction nommée permettra d'éviter les erreurs, les oublis, les pertes. Ajoutons qu'une fonction rend votre code plus facile à lire et, au besoin, plus simple à corriger. La fonction se présente comme un bloc d'instructions qu'on peut ouvrir pour en modifier les composantes, mais qui, enchâssées dans un objet de l'environnement, ne prend plus de place dans vos scripts. La structure d'une fonction est assez simple. Elle est créée avec la fonction `function()` et se présente ainsi:

> `<nom_de_la_fonction> <- function(<arguments_facultatifs>) {`
>
> `<instructions>`
>
> `}`

Il n'est pas obligatoire d'insérer des arguments dans la parenthèse de la fonction. S'il n'y en a pas, c'est que vous aurez fourni dans les instructions tout ce dont la fonction a besoin pour être exécutée. Les arguments peuvent également être définis par défaut et leurs valeurs pourront être modifiées lors de son utilisation, si nécessaire. Construisons une première fonction très simple qui permettra d'imiter le lancer d'un dés à 6 faces. On peut utiliser la fonction `sample.int()` pour créer une telle fonction:

```{r}
lancer_du_de <- function() {
  sample.int(n=6, size=1, replace = TRUE)
}

lancer_du_de()
```

\
Cette fonction n'a pas besoin d'argument, elle contient tout ce dont elle a besoin. Vous l'exécutez autant de fois que vous le souhaitez et vous aurez toujours un nombre compris entre 1 et 6. Supposons maintenant que vous souhaitiez offrir à l'utilisateur de la fonction la possibilité de déterminer à l'avance combien de fois le dé devra être lancé automatiquement. Vous pourrez définir un argument par défaut de sorte que la fonction puisse fonctionner même si rien n'est indiqué dans la parenthèse, mais l'utilisateur pourra effectuer autant de "lancer de dés" qu'il voudra en modifiant la valeur de l'argument:

```{r}

lancer_du_de <- function(nbre_fois = 1) {
  mes_lancers <- rep(NA, nbre_fois)
  for(i in seq_along(mes_lancers)) {
    mes_lancers[i] <- sample.int(n=6, size = 1, replace = TRUE)
  }
  return(mes_lancers)
}

# Essayez
lancer_du_de()
lancer_du_de(nbre_fois = 25)

```

Dans la fonction `lancer_du_de()` ci-dessus, on définit une valeur par défaut pour l'argument `nbre_de_fois=`, 1. Si on ne modifie pas cette valeur avant d'exécuter la fonction, celle-ci sera utilisée dans les instructions. Que comprennent ces instructions?

| Instruction de la fonction `lancer_du_de()`                   | Explication                                                                                                                                                                                                                                                                                             |
|-------------------|-----------------------------------------------------|
| `lancer_du_de <- function(nbre_fois = 1)`                     | Assignation d'un nom à la fonction et définition de son argument par défaut.                                                                                                                                                                                                                            |
| `mes_lancers <- rep(NA, nbre_fois)`                           | Instruction 1: création d'un vecteur composé de valeurs nulles (`NA`) dont la longeur correspond à l'argument de la fonction.                                                                                                                                                                           |
| `for(i in seq_along(mes_lancers))`                            | Instruction 2: création d'une boucle `for()` - le nombre d'itération sera équivalent au nombre d'éléments du vecteur créé à l'instruction 1.                                                                                                                                                            |
| `mes_lancers[i] <- sample.int(n=6, size = 1, replace = TRUE)` | Instruction de la boucle `for()` : à chaque itération, `sample.int()` génère un nombre aléatoire compris entre 1 et 6. C'est le lancé du dé à proprement parler. Le résultat de chaque lancer est emmagasiné dans l'une des cases du vecteur `mes_lancers`. Cette valeur prend donc la place d'un `NA`. |
| `return(mes_lancers)`                                         | Instruction 3: on demande à la fonction de renvoyer le vecteur `mes_lancers`, composé des "coups de dés".                                                                                                                                                                                               |

## Une fonction plus utile

Trève d'amusement, il est maintenant temps de construire une fonction qui nous servira plus souvent dans le cadre du cours. Une tâche que vous devez répéter chaque fois que vous commencez à travailler est l'importation et l'installation des extensions dont vous avez besoin dans le cadre de votre travail. On pourrait construire une fonction qui nous demande quelles extensions sont à installer et qui, ensuite, avec la série de noms d'extensions que nous lui avons fournie, vérifie si elles sont déjà installées et, dans le cas contraire, fait cette action.

Nous pouvons décomposer notre tâche en deux parties. Dans un premier temps, nous allons créer la fonction principale. Une fois que nous aurons construit et testé cette fonction, nous pourrons l'intégrer à une nouvelle fonction qui s'occupera de récolter la liste des extensions que nous souhaitons installer.

#### Première partie

Nous allons donc définir une fonction appelée `installer_extension()` qui contiendra une instruction avec laquelle vous êtes désormais familier·ère :

```{r}
installer_extension <- function(x="stringr") {
  if(!x %in% rownames(installed.packages())) {install.packages(x)}
}

# Essayez! Insérer un nom d'extension comme argument
installer_extension(x="data.table")
```

L'argument par défaut est composé d'un nom d'extension que vous connaissez maintenant bien, si vous avez fait l'Atelier 11. L'instruction comprend une structure de contrôle `if()` qui dit à R qu'il doit installer l'extension définie comme argument si son nom ne se trouve pas parmi les noms de fonctions installées.

Pour tester cette fonction, vous pouvez désinstaller une extension puis donner ensuite son nom à notre fonction maison. Observez le résultat.

```{r}
# Désinstaller une extension
remove.packages("data.table")

# Réinstaller cette fonction avec notre fonction maison
installer_extension("data.table")
```

#### Deuxième partie

Notre fonction fait bien le travail pour laquelle nous l'avons créée, mais on ne peut lui passer qu'un seul élément à la fois et on doit l'exécuter manuellement autant de fois que nous lui passons d'éléments. Nous pouvons faire mieux!

Créons d'abord un vecteur comprenant quelques noms d'extension que nous aimerions installer. Ensuite, passons ce vecteur à une boucle `for()` en réutilisant la fonction que nous avons créée ci-dessus. Nous allons également ajouter à cette boucle la fonction d'activation `library()`, pour que toutes les extensions qu'on veut utiliser soit disponibles:

```{r}
mes_extensions <- c("data.table", "proustr", "stringr", "rbenchmark", "lsa")

# Désinstaller les extensions
sapply(mes_extensions, remove.packages)

# Boucle qui installe et active chaque extension indiquée dans le vecteur mes_extensions
for(i in seq_along(mes_extensions)){
  installer_extension(x = mes_extensions[i])
  library(mes_extensions[i], character.only = TRUE)
}

```

À chaque itération de la boucle, la fonction `installer_extension()` prend un élément du vecteur comme argument et installe l'extension si ce n'est déjà fait. Une autre instruction de la boucle active cette extension.

On voudrait maintenant ne pas avoir à créer le vecteur d'extensions manuellement et ne pas avoir à écrire la boucle pour que le processus d'installation/activation soit déclenché. Pour arriver à ce résultat, nous devrons :

1.  Utiliser `readline()` pour indiquer à R qu'il doit nous demander quelles extensions nous souhaitons installer/activer, et assigner le résultat à un vecteur;
2.  À l'aide de la fonction de base `strsplit()`, séparer les noms d'extensions que nous aurons fournis à R pour qu'ils forment des éléments séparés;
3.  Transformer la liste produite par `strsplit()` en un vecteur avec `unlist()`;
4.  Créer une boucle qui prendra ce vecteur et qui passera ses éléments, un à un, à notre fonction maison.

Ces différentes opérations seront intégrées comme lignes d'instructions à une fonction plus générale appelée `lancer_extensions()` (avec le "s" comme marque du pluriel)

Le résultat pourrait ressembler à ceci:

```{r}
lancer_extensions <- function() {
  
  # On crée ici notre fonction maison, mais, cette fois, on ne donne aucun argument par défaut
  installer_extension <- function() {
  if(!x %in% rownames(installed.packages())) {install.packages(x)}
    }
  
  # On demande à R de nous demander quelles extensions sont à installer
  noms_extensions <- readline(prompt = "Quelles extensions activer? Sépare chaque nom d'extension par une virgule (ex.: data.table,dplyr,ggplot2). Réponse: ")
  
  # On segmente la réponse que nous avons fournie en prenant la virgule comme élément séparateur, puis on transforme la liste en vecteur
  noms_extensions_l <- strsplit(noms_extensions, ",")
  noms_extensions_v <- unlist(noms_extensions_l)

  # Boucle qui prend chaque élément du vecteur ci-dessus, le passe à la fonction m la fonction d'activation library()
  for(i in seq_along(noms_extensions_v)){
    if(length(noms_extensions_v) > 0){
      installer_extension(x = noms_extensions_v[i])
      library(noms_extensions_v[i], character.only = TRUE)
    }
  }
}

```

On n'a plus qu'à exécuter cette dernière fonction (idéalement dans la console) pour que R nous demande quelles fonctions sont à installer et à activer.

```{r}

lancer_extensions()

```

Si vous estimez cette fonction utile, vous pouvez la copier dans un simple fichier .R (exemple: mes_fonctions.R). Vous pourrez enregistrer ce fichier dans votre dossier de travail et appeler ce fichier et les fonctions qu'il contient, au début de vos propres scripts, avec la fonction `source()`, comme ceci:

```{r}
source("mes_fonctions.R")
lancer_extensions()
```

## Fonction nommée VS fonction anonyme (pour étudiant·e avancé·e)

Nous avons créé jusqu'ici deux fonctions nommées, `lancer_du_de()` et `lancer_extensions()`. On peut aussi créer des fonctions anonymes qui ne serviront qu'une fois, par exemple à l'intérieur d'une autre fonction qui prend comme argument une fonction et ses arguments.

Reprenons notre fonction du lancé du dé. Elle est construite comme suit:

```{r}
lancer_du_de <- function(nbre_fois = 1) {
  mes_lancers <- rep(NA, nbre_fois)
  for(i in seq_along(mes_lancers)) {
    mes_lancers[i] <- sample.int(n=6, size = 1, replace = TRUE)
  }
  return(mes_lancers)
}

lancer_du_de(25)
```

Au lieu d'une boucle for(), on aurait pu, avec avantage, utiliser une fonction `sapply()` qui prend, rappelons-le, 1) un argument `X=`, l'objet sur lequel se fait l'itération; 2) une fonction qui prendra chaque élément défini par `X=`; 3) les arguments éventuels de cette même fonction, séparés les uns des autres par une virgule. C'est ici qu'une fonction anonyme peut être utile.

```{r}
# La même fonction peut être écrite plus simplement avec sapply()
lancer_sapply <- function(nbre_fois=1){
  sapply(X=1:nbre_fois, FUN = function(nbre_fois) sample.int(n=6, size = 1, replace = TRUE))
}

# Essayez
lancer_sapply()
lancer_sapply(25)
```

La fonction anonyme est créée au sein même de `sapply()` et ne pourra pas être réutilisée ailleurs. Elle ne remplit qu'une tâche, qui est d'indiquer à `sapply()` la fonction à utiliser sur les éléments du vecteur fourni en entrée. Cette fonction n'a pas de nom et n'a pas non plus besoin d'être encadrée par des accolades.

## Pour aller plus loin

Sophie Baillargeon, [Fonctions en R](https://stt4230.rbind.io/programmation/fonctions_r/#fonction-anonyme)

Data Carpentry, "[Creating functions](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/)"

Garrett Grolemund, [*Hands-On Programming with R*](https://rstudio-education.github.io/hopr/), Beijing/Cambridge/Farnham/Köln/Sebastopol/Tokyo, O'Reilly, 2014.
