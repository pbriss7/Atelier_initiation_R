---
title: "Atelier 5 : filtrer les données d'un tableau"
author: "Pascal Brissette (U. McGill)"
date: 13 septembre 2022
format: pdf
editor: visual
---

![Image libre de droit (Pixabay)](images/water-ga752c3e99_1280.png){fig-align="center" width="209"}

Dans cet atelier, vous apprendrez à filtrer des tableaux de données, c'est-à-dire à extraire d'un tableau un sous-ensemble de données. Vous avez déjà fait un tel type d'opération dans l'atelier précédent. Vous avez vu que nous pouvions utiliser les opérateurs d'indexation (`[ , ]` et `$`) pour isoler ou extraire une ou pluseurs lignes ou colonnes d'un tableau, voire la valeur d'une seule cellule.

Dans l'atelier, nous allons nous pratiquer à extraire quelques sous-ensembles de données du tableau construit dans le dernier atelier. S'il n'est pas déjà dans votre environnement de travail, nous allons l'y importer.

```{r}
if(!"ouvrages" %in% ls()) {ouvrages <- readRDS("donnees/ouvrages.RDS")}
str(ouvrages)

# On extrait les lignes 2 à 4 et les colonnes 3 à 5
ouvrages[2:4, 3:5]

# On extrait les lignes 1, 3 et 5, ainsi que les colonnes 3 et 5
ouvrages[c(1,3,5), c(3,5)]

# On extrait toutes les lignes et uniquement les colonnes "auteur.trice" et "annee.publication"
ouvrages[ , c("auteur.trice", "annee.publication")]
```

Pour isoler des sous-ensembles de données du tableau `ouvrages`, nous avons utilisé ci-dessus des vecteurs numériques et des vecteurs de caractères. Nous aurions aussi pu utiliser, dans les crochets d'indexation, des vecteurs de type logique, `TRUE`, `FALSE`. Le tableau est composé de huit lignes et de cinq colonnes. Pour chacune des lignes et des colonnes, nous allons utiliser `TRUE` si nous souhaitons l'extraire et `FALSE` dans le cas contraire.

```{r}
ouvrages[c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE), c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE)]
```

Cette façon de faire ne semble pas très efficace *a priori*, mais vous verrez qu'elle constituera un atout dans le filtrage des données par condition.

## Isoler des données avec les opérateurs `==`, `>` et `<`

Prenons d'abord un opérateur de base, `==`. Il ne faut pas le confondre avec l'opérateur déjà vu, `=`. Ce dernier en est un d'assignation et permet par exemple de définir des arguments dans une fonction. L'opérateur `==` sert à vérifier l'équivalence entre deux éléments et il renvoit une donnée de type logique, `TRUE` si les deux éléments comparés sont identiques, ou `FALSE` s'ils sont différents. Sachant cela, on peut demander à R de filtrer le tableau en fonction d'une date ou d'un nom d'auteur, ou encore d'un titre:

```{r}
ouvrages[ouvrages$annee.publication == 1892,]
ouvrages[ouvrages$auteur.trice == "Lamartine",]
ouvrages[ouvrages$oeuvre == "Corinne",]
```

Que vient-il de se passer? Nous avons mis en position d'indexation `i` du tableau `ouvrages`, à la gauche de l'opérateur `==`, un vecteur de ce tableau, soit la colonne `annee.publication`, puis avons indiqué, de l'autre côté de l'opérateur `==` une date, soit le nombre entier `1892`. R va donc passer en revue tous les éléments de cette colonne spécifique et renvoyer à la fonction d'indexation `TRUE` si la date trouvée correspond au nombre entier indiqué en `i` et `FALSE` dans le cas contraire. Il se trouve ainsi à faire automatiquement l'opération que nous avons faite plus haut en insérant manuellement `TRUE` ou `FALSE` dans un vecteur d'indexation.

On pourrait également utiliser les opérateurs de grandeur `<` et `>` pour filtrer les ouvrages dont la date de publication est plus grande que, disons, 1840 (condition simple), ou encore les ouvrages dont la date de publication se situe entre 1750 et 1830 (double condition).

```{r}
ouvrages[ouvrages$annee.publication > 1840,]

ouvrages[ouvrages$annee.publication > 1750 & ouvrages$annee.publication < 1830,]
```

À nouveau, R filtre les lignes en fonction d'une condition appliquée au vecteur `annee.publication`, qui est une colonne du tableau `ouvrages`. Il vérifie, pour chaque ligne du tableau, si la valeur indiquée au croisement de la ligne et de la colonne `annee.publication` est plus grande que 1840. Le cas échéant, il considère que la réponse à la question `ouvrages$annee.publication > 1840` est `TRUE` et il extrait la valeur. La deuxième instruction suit le même principe: R évalue, pour chaque ligne, si la valeur entrée dans la colonne `annee.publication` est plus grande que 1750 et (opérateur `&`) plus petite que 1830. Le cas échéant, il considère que la réponse à la question `ouvrages$annee.publication > 1840` est `TRUE` et il extrait la valeur.

Importons dans l'environnement de RStudio un "vrai" jeu de données provenant du portail Données Québec. Ce [jeu de données](https://www.donneesquebec.ca/recherche/dataset/longs-metrages-diffuses-a-radio-canada) "répertorie les diffusions de longs métrages, tous genres confondus, à Radio-Canada, durant la décennie 2010".

```{r}

rc <- read.csv("donnees/rc_longs_metrages.csv", header = TRUE)
View(rc)
```

Le tableau de données importé comporte 5 045 lignes et 14 colonnes. Ce ne serait pas une bonne idée d'imprimer ce tableau dans la console. D'une part, vous risqueriez de saturer la mémoire de RStudio et de geler le programme. D'autre part, peu importe ce que vous cherchez exactement dans votre tableau, R le trouvera beaucoup mieux et plus rapidement que vous, si vous lui donnez les bonnes instructions.

Tentons d'extraire, avec ce que nous connaissons déjà, les titres dont la `COTE_MEDIAFILM` est de 1 (donc les films les mieux cotés. `COTE_MEDIAFILM` est ici un nom de colonne. Pour

```{r}

films_cote_1 <- rc[rc$COTE_MEDIAFILM == 1, ]


# On peut visualiser le résultat en utilisant la fonction View()
View(films_cote_1)

```

On constate que le résultat contient plusieurs doublons. On pourrait donc filtrer à nouveau ce jeu de données pour afficher seulement la première occurrence de chaque document.

```{r}

View(films_cote_1[!duplicated(films_cote_1$TITRE_FRANÇAIS), ])

# Si vous exécutez l'expression utilisée comme filtre, vous verrez que R a vérifié chaque élément de la colonne `TITRE_FRANÇAIS` et s'est assuré que chacun de ces éléments répondait à la condition en renvoyant un booléen (TRUE/FALSE)
!duplicated(films_cote_1$TITRE_FRANÇAIS)
```

## Isoler un sous-ensemble de documents (lignes) avec la fonction `grep()`

Supposons que vous souhaitiez consulter tous les titres de longs-métrages diffusés sur Radio-Canada entre 2010 et 2020 contenant le mot "femme". La colonne `TITRE_FRANÇAIS` de notre tableau, formé d'un long vecteur comprenant autant d'éléments qu'il y a de lignes dans le tableau, est le lieu où faire cette recherche. Dans une situation comme celle-ci, vous ne pourriez simplement utiliser l'opérateur d'identité introduit ci-dessus (`==`), parce que le mot "femme" n'est potentiellement qu'un segment des titres des longs-métrages. Si vous utilisez cet opérateur, par exemple comme dans l'exemple ci-dessous, vous n'obtiendrez que les lignes dont le `TITRE_FRANÇAIS` est exactement "femme". Essayons:

```{r}
rc[rc$TITRE_FRANÇAIS == "femme",]
```

Aucun titre ne correspond exactement à cette chaîne de caractères précise. Mais cela ne signifie pas qu’aucun titre ne contient le mot “femme”. Pour le vérifier, on peut utiliser la fonction `grep()`, qui sert à chercher des éléments spécifiques dans un vecteur de chaînes de caractères (dans notre cas, ce sera la colonne "TITRE_FRANÇAIS" du tableau). La fonction `grep()` recherche des motifs, appelés *patterns*, dans ces chaînes. Son premier argument est le motif que vous voulez chercher, ici `pattern="femme"`, et le deuxième est le vecteur dans lequel la recherche va se faire, ici `x=rc$TITRE_FRANÇAIS`. Regardez bien ce que la fonction renvoie comme résultat.

```{r}
# On isole la colonne avec l'opérateur `$`, comme on a appris à le faire dans le dernier atelier
grep(pattern = "femme", x = rc$TITRE_FRANÇAIS)

```

À quoi ces nombres entiers correspondent-ils selon vous?

Réponse: aux positions des éléments du vecteur `rc$TITRE_FRANÇAIS` où la fonction `grep()` a trouvé la chaîne de caractères "femme". Cette suite de nombres forme un vecteur et, comme ce vecteur correspond à une colonne dans le tableau de données `rc`, cela veut dire que ces nombres sont aussi des numéros de lignes du tableau dont `rc$TITRE_FRANÇAIS` forme une colonne.

Vous souhaitez en avoir la preuve? Voyons:

```{r}

# On crée un vecteur numérique avec la fonction `grep()`
nos_lignes <- grep("femme", rc$TITRE_FRANÇAIS)

# On filtre le tableau de données avec ce vecteur:
rc[nos_lignes, c("TITRE_ORIGINAL", "TITRE_FRANÇAIS")]

```

## Ordonner les lignes d'un tableau avec la fonction `order()`.

Une autre fonction pratique, dans la manipulation des tableaux, est la fonction `order()`. Celle-ci prend un vecteur en entrée et ordonne les éléments de ce vecteur du plus grand au plus petit ou, si l'argument `decreasing=` est réglé à `TRUE`, du plus petit au plus grand. Si on voulait par exemple que le tableau `rc` soit ordonné selon la date de production des longs-métrages, de la date la plus lointaine vers la plus récente, on fournirait à R la commande suivante:

```{r}
head(
  rc[order(rc$ANNÉE_PRODUCTION),]
  )
```

## Les expressions régulières (regex)

La fonction `grep()` et de nombreuses autres fonctions très puissantes dans R utilisent des expressions régulières (ou *regex*, en anglais) pour saisir, dans des textes, des chaînes de caractères variées. Les expressions régulières sont utilisées dans d'autres contextes, notamment la programmation, mais elles nous intéressent en analyse de texte parce qu'elles font sauver temps et ressources. Nous avons, ci-dessus, utilisé le motif "femme" dans la fonction `grep()` et R a donc cherché à travers les différents éléments de la colonne `TITRE_FRANÇAIS` du tableau `rc` cette suite précise de caractères. Dans les expressions régulières, les lettres (a, b, c...; A, B, C...) sont bel et bien des lettres, mais il existe plusieurs autres symboles et structures permettant d'étendre nos capacités de recherche. Par exemple, si nous souhaitons saisir toutes les lignes du tableau `rc` où apparaissaient à la fois les motifs "femme" et "Femme", nous pouvons le faire de la manière suivante en utilisant `grep()`:

```{r}

rc[grep(pattern = "[Ff]emme", x = rc$TITRE_FRANÇAIS) , c("TITRE_ORIGINAL", "TITRE_FRANÇAIS")]

```

Si vous aviez souhaité exclure les cas de figure où le mot femme est écrit avec la marque du pluriel, vous auriez pu ajouter au motif "\[Ff\]emme" une balise de mot: "\[Ff\]emme\\\\b".

```{r}
rc[grep(pattern = "[Ff]emme\\b", x = rc$TITRE_FRANÇAIS) , c("TITRE_ORIGINAL", "TITRE_FRANÇAIS")]

```

# Principes et opérateurs de base

Qu'est-ce qu'une expression régulière? Ce sont des séquences de caractères (lettres, ponctuations, symboles) qui forment des motifs permettant de trouver d'autres séquences de caractères dans des textes.

Interrogé à ce sujet, voici la définition très claire qu'en propose ChatGPT :

> Une **expression régulière** (ou **regex**, pour “regular expression” en anglais) est une séquence de caractères qui définit un **motif** utilisé pour rechercher, correspondre ou manipuler des chaînes de caractères dans du texte. Autrement dit, c’est un outil puissant qui permet de spécifier des règles pour trouver des fragments de texte qui respectent certaines conditions. Les expressions régulières sont largement utilisées dans divers domaines comme la programmation, le traitement de texte, l’analyse de données et l’automatisation. (OpenAI, ChatGPT-4o, version 21 sept. 2024)

Une expression régulière peut prendre la forme exacte d'un mot ou d'une expression en langage naturel. Par exemple, "Montréal" attrapera très exactement cette chaîne précise de caractères dans un texte, "Montréal", mais l'expression attrapera également "Montréalais", "Montréalaise" et "Montréalaises", à moins que vous n'ajoutiez une balise de fin de mot: "Montréal\\\\b". Dans cette dernière expression, les deux barres diagonales indiquent au logiciel que "b" n'est pas à prendre comme la lettre "b" d'un mot, mais comme un opérateur, une balise de mot. Dans la plupart des langages de programmation, une seule barre est utilisée. Les deux barres sont spécifiques à R, où elles servent à "échapper" l'opérateur d'échappement lui-même...

Voici quelques-uns des symboles et opérateurs les plus communs:

+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Expression | Description                                                                                                                   | Éléments saisis et exemples                                                                                                                                                                                                                                                                                                                           |
+============+===============================================================================================================================+=======================================================================================================================================================================================================================================================================================================================================================+
| `a, b, c…` | L'expression saisit la lettre ou le chiffre tel qu'il est exprimé.                                                            | "a", "b", "c",                                                                                                                                                                                                                                                                                                                                        |
|            |                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                       |
| `A, B, C…` |                                                                                                                               | "A", "B", "C"                                                                                                                                                                                                                                                                                                                                         |
|            |                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                       |
| `1, 2, 3`  |                                                                                                                               | "1", "2", "3"                                                                                                                                                                                                                                                                                                                                         |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\b`      | Balise de mot                                                                                                                 | L'expression `jour` attrapera aussi bien le mot "jour" que "au**jour**d'hui", tandis que `\\bjour\\b` n'attrapera que le mot "jour" au singulier, tout en minuscules.                                                                                                                                                                                 |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\w`      | N'importe quel caractère d'un mot                                                                                             | `\\w` saisira une seule lettre, minuscule ou majuscule, d'une suite de lettres encadrées de blancs typographiques ou de ponctuations. Par exemple, `str_extract("Victor Hugo", "\\w")`, renverra seulement la première lettre du premier mot, "V".                                                                                                    |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\s`      | Une espace (simple ou tabulation)                                                                                             | `\\s` saisira une espace, une seule, à moins d'être suivi de l'opérateur `+`. Ainsi, `strsplit("Victor Hugo", "\\s")`, en base R, séparera le prénom et le nom et renverra une liste comprenant les deux éléments.                                                                                                                                    |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `.`        | N'importe quel caractère (lettre, chiffre, ponctuation, espace simple), une seule fois.                                       | `\\bMontr.al\\b` saisirait le mot "Montréal", "Montreal", mais également "Montrial", "Montr'al", "Montr al", etc. Très pratique pour attraper dans un texte des mots dont on soupçonne qu'ils pourraient avoir été orthographiés de différentes manières.                                                                                             |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\.`      | Un point, tout simplement. Les deux barres transversales inversées annulent la fonction spéciale accordée autrement au point. | La fonction `str_replace_all("Je mange une pomme","\\.", "!")` renverra "Je mange une pomme!", mais `str_replace_all("Je mange une pomme",".", "!")` renverra "!!!!!!!!!!!!!!!!!!!"                                                                                                                                                                   |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `?`        | Cet opérateur est un quantifieur "paresseux" (*lazy quantifier*).                                                             | Opérateur très utile pour indiquer que, dans une expression, une lettre ou un symbole est facultatif, que l'on veut attraper un mot, peu importe qu'une certaine lettre soit ou non présente. Par exemple `\\bMontréalaise?\\b` saisira aussi bien "Montréalais" que "Montréalaise". Le caractère `?` rend facultatif le "e" qui précède l'opérateur. |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\?`      | Un point d'interrogation, tout simplement                                                                                     | Le point d'interrogation est ici "échappé" par les barres diagonales.                                                                                                                                                                                                                                                                                 |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `+`        | Cet opérateur est un quantifieur gourmand (*greedy quantifier*).                                                              | `Ah+` saisira "Ah", mais aussi "Ahh", "Ahhh", et ainsi de suite, jusqu'à ce que la fonction de recherche trouve un caractère autre que "h".                                                                                                                                                                                                           |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `\\+`      | Un opérateur mathématique, tout simplement                                                                                    | Les barres diagonales "échappent" le symbole mathématique.                                                                                                                                                                                                                                                                                            |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `^`        | Marque le début d'une chaîne de caractères (ce qui suit doit se trouver au tout début de la chaîne).                          | Supposons que nous ayons 1000 documents à filtrer selon que le premier mot du document soit "Femme". On pourra utiliser une fonction de recherche avec, comme motif, `^Femme`. Si le mot est présent dans l'un ou l'autre des documents, mais qu'il n'est pas le tout premier mot, le texte ne sera pas retenu.                                       |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `$`        | Marque la fin d'une chaîne de caractères (ce qui précède doit se trouver à la toute fin de la chaîne).                        | À l'inverse de l'exemple précédent, `femme$` saisira les documents qui se **terminent** par "femme" (sans la marque du pluriel: le "e" final de "femme" est immédiatement suivi du symbole `$`).                                                                                                                                                      |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `[ ]`      | Tout caractère, ponctuation ou symbole qui se trouve à l'intérieur, y compris l'espace ou la tabulation, une seule fois.      | L'expression `Montr[ée]al` saisira à la fois "Montréal" et "Montreal".                                                                                                                                                                                                                                                                                |
+------------+-------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

```{r exemple simple}
# Exemple simple d'une expression régulière qui repère et extrait tous les mots commençant par une majuscule. 

texte <- "Victor Hugo, Emile Zola, et Jean-Paul Sartre sont des écrivains célèbres." 

pattern <- "\\b[A-Z][a-z]+\\b"

str_extract_all(texte, pattern) |> unlist()

```

# Groupes de capture

Il existe d'autres symboles et quantifieurs que vous découvrirez à l'usage, mais une introduction aux expressions régulières serait incomplète si elle ne comprenait également une présentation des groupes de capture (*group constructs*). Ces constructions permettent de regrouper des parties d’une expression régulière pour diverses opérations, comme la capture de sous-chaînes.

+--------------+---------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| Expression   | Description                                                                                                                                 | Exemple                                                                                                                                         |
+==============+=============================================================================================================================================+=================================================================================================================================================+
| `(?=motif)`  | Assertion d'anticipation (*positive lookahead*). Vérifie qu'un motif suit la chaine qu'on souhaite attraper.                                | Soit la phrase: "Simone de Beauvoir a écrit *Le Deuxième sexe* (1949). *Le Deuxième sexe* est un essai philosophique de de Beauvoir."\          |
|              |                                                                                                                                             | \                                                                                                                                               |
|              |                                                                                                                                             | L'expression `Le Deuxième sexe(?=\\s\\(\\d{1,4}\\))` saisira la première occurrence du titre, mais non la seconde.                              |
+--------------+---------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| `(?<=motif)` | Assertion de rétrovision (*positive lookbehind*). Vérifie qu'un motif précède une chaine qu'on souhaite attraper.                           | Dans l'exemple précédent, l'expression `(?<=Beauvoir a écrit )Le Deuxième sexe` attrapera la première occurrence du titre, mais non la seconde. |
+--------------+---------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| `(?!motif)`  | Assertion d'anticipation négative (*negative lookahead*). Vérifie qu'un certain motif ne suit pas un autre motif qu'on souhaite attraper.   | Soit la séquence suivante: "Victor Hugo est un écrivain. Victor s'intéresse aussi à la politique."                                              |
|              |                                                                                                                                             |                                                                                                                                                 |
|              |                                                                                                                                             | \                                                                                                                                               |
|              |                                                                                                                                             | Le motif `Victor(?!\sHugo)` saisira la deuxième occurence de "Victor", mais non la première.                                                    |
+--------------+---------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------+
| `(?<!motif)` | Assertion de rétrovision négative (*negative lookbehind*). Vérifie qu'un certain motif ne précède pas un autre motif qu'on souhaite saisir. | Soit la séquence suivante: "Victor Hugo est un écrivain. Hugo s'intéresse aussi à la politique."                                                |
|              |                                                                                                                                             |                                                                                                                                                 |
|              |                                                                                                                                             | Le motif `(?<!Victor\s)Hugo` saisira la deuxième occurence de "Hugo", mais non la première.                                                     |
+--------------+---------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------+

Vous trouverez ci-dessous une [antisèche (aide-mémoire) sur les expressions régulières](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) proposée par RStudio. Elle vous sera utile une fois que vous vous serez un peu familiarisé avec les expressions régulières. Le mieux est de trouver en ligne des ateliers qui vous permettront de vous pratiquer. Voyez par exemple le site [Data Carpentry](https://librarycarpentry.org/lc-data-intro/01-regular-expressions/). Les expressions régulières étant utilisées dans plusieurs langages de programmation et logiciels d'édition, les ressources pour en apprendre le maniement sont très nombreuses. En explorant cette documentation, gardez à l'esprit que, dans R, le caractère d'échappement `\` doit être doublé `\\`.

### [![Crédit: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf](images/regex.png)](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

## Défi

1.  À partir de la table `rc`, composez un sous-ensemble de données comprenant seulement les longs-métrages produits par la Grande-Bretagne (GB).
2.  Éliminez de ce sous-ensemble toutes les colonnes à l'exception de `TITRE_ORIGINAL`, `TITRE_FRANÇAIS`, `PAYS_1.`
3.  Quelle(s) fonctions pourrai(en)t vous renvoyer les dimensions de ce tableau de données? Exécutez-là et trouvez le nombre de lignes et de colonnes de ce sous-ensemble.
4.  Combien de films de ce sous-ensemble contiennent, dans `TITRE_FRANÇAIS`, le mot "homme" dans toutes ses déclinaisons ("Homme" et "homme" au singulier et au pluriel)?
