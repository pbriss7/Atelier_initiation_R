---
title: "Atelier 14: les fonctions"
author: "Pascal Brissette (U. McGill)"
date: 23 septembre 2022
format: pdf
editor: visual
---

[![Image vectorielle libre de droits, Pixabay](images/gear-wheel-g4c97afd80_1280.png){fig-align="center"}](https://pixabay.com/fr/vectors/roue-dent%c3%a9e-%c3%a9quipement-rouages-dent-310906/)

```{r}
#| echo: FALSE
inst_pack_f <- function(x) {
  if(!x %in% rownames(installed.packages())) {
    install.packages(x)
    }
  require(x, character.only = TRUE)
}

extensions_v <- c("stringr",
                  "tm"
                  )

lapply(extensions_v, inst_pack_f)

```

Dans R, les fonctions sont des objets qui, comme n'importe quel objet (vecteur, liste, tableau de données, etc.), peuvent être créés de toutes pièces et modifiés. Les fonctions que vous avez utilisées jusqu'ici proviennent principalement de R natif ou d'extensions, mais rien ne vous empêche de créer vos propres fonctions, destinées à remplir des tâches spécifiques. Vous y êtes même fortement encouragé·e·s. Pourquoi?

Tout d'abord, parce qu'une fonction est réutilisable et peut donc être mobilisée n'importe quand, dans n'importe quel script ou programme, pour effectuer une tâche donnée. Il y a donc un gain de temps: vous n'avez pas à vous répéter. Ensuite, si vous devez constamment recycler des lignes de codes ici et là comme autant de pièces d'un puzzle pour effectuer une opération, le fait d'assembler ces pièces en une fonction nommée permettra d'éviter les erreurs, les oublis, les pertes. Ajoutons qu'une fonction rend votre code plus facile à lire et, au besoin, plus simple à corriger.

La fonction se présente comme un bloc d'instructions qu'on peut ouvrir pour en modifier les composantes. La structure d'un tel objet est assez simple. Il est créé avec `function()` et se présente ainsi:

> `<nom_de_la_fonction> <- function(<arguments_facultatifs>) {`
>
> `<instructions>`
>
> `}`

Lorsqu'on crée une fonction, il n'est pas obligatoire d'insérer des arguments dans la parenthèse de la fonction. S'il n'y en a pas, c'est que vous aurez fourni dans les instructions tout ce dont la fonction a besoin pour être exécutée, même les données. Cependant, une fonction qui intègre les données n'est pas réutilisable avec d'autres données. Idéalement, une fonction atteint un niveau minimal d'abstraction qui permet de l'utiliser avec différents jeux de données.

Prenons un exemple concret.

Une tâche que vous aurez souvent à réaliser dans vos analyses textuelles est le prétraitement. Cette tâche implique plusieurs décisions. Souhaite-t-on imposer le bas de casse? Veut-on supprimer les nombres, les symboles, les mots fonctionnels?

Une fonction de prétraitement qui ne prendrait en entrée aucun argument pourrait ressembler à ceci:

```{r}

pretraitement_f <- function() {
  
  # Vérification que l'extension 'tm' est bien disponible
  if (!requireNamespace("tm", quietly = TRUE)) {
    stop("L'extension 'tm' est requis pour cette fonction.")
  }
  
  # Importation du jeu de données
  maria_v <- readLines("donnees/maria_sans_epitexte.txt")
  
  # Conversion en minuscules
  maria_v <- tolower(maria_v)
  
  # Segmentation du texte en unités lexicales (tokens)
  maria_v <- strsplit(maria_v, "\\W") |> unlist()
  
  # Suppression des nombres
  maria_v <- gsub(pattern = "[[:digit:]]+", replacement = " ", maria_v, perl = TRUE)
  
  # Suppression de la ponctuation
  maria_v <- gsub(pattern = "[[:punct:]]+", replacement = " ", maria_v, perl = TRUE)
  
  # Suppression des mots fonctionnels
  maria_v <- maria_v[!maria_v %in% tm::stopwords(kind ="fr")]
  
  # Élimination des éléments sans contenu, s'il y en a
  maria_v <- maria_v[!maria_v == ""]
  
  # Renvoi du résultat
  return(maria_v)
}

# Exécution de la fonction et transfert du résultat dans maria_pretraite_v
maria_pretraite_v <- pretraitement_f()

# observation du résultat
maria_pretraite_v[1:100]
```

Une telle fonction remplit peut-être sa mission ici, mais elle n'est pas suffisamment abstraite pour pouvoir être réutilisée ailleurs, avec d'autres données. De plus, elle n'offre aucun choix à l'utilisateur et ne tient donc pas compte des différentes décisions que ce dernier doit prendre en fonction de sa question de recherche.

## Vers une fonction générique et réutilisable

Pour améliorer notre fonction, nous allons commencer par "sortir" les données du corps de l'objet et faire en sorte que celui-ci puisse prendre en entrée des jeux de données variables.

```{r}
pretraitement_f <- function(donnees) {
  
  # Vérification que l'extension 'tm' est bien disponible
  if (!requireNamespace("tm", quietly = TRUE)) {
    stop("L'extension 'tm' est requis pour cette fonction.")
  }
  
  # Conversion en minuscules
  donnees <- tolower(donnees)
  
  # Segmentation du texte en unités lexicales (tokens)
  donnees <- strsplit(donnees, "\\W") |> unlist()
  
  # Suppression des nombres
  donnees <- gsub(pattern = "[[:digit:]]+", replacement = " ", donnees, perl = TRUE)
  
  # Suppression de la ponctuation
  donnees <- gsub(pattern = "[[:punct:]]+", replacement = " ", donnees, perl = TRUE)
  
  # Suppression des mots fonctionnels
  donnees <- donnees[!donnees %in% tm::stopwords(kind ="fr")]
  
  # Élimination des éléments sans contenu, s'il y en a
  donnees <- donnees[!donnees == ""]
  
  # Renvoi du résultat
  return(donnees)
}

# Puisque les données ne sont plus contenues dans la fonction, il faut d'abord les charger en mémoire.

maria_v <- readLines("donnees/maria_sans_epitexte.txt")

# On passe ensuite ce vecteur texte à la fonction.
maria_pretraite_v <- pretraitement_f(donnees = maria_v)

maria_pretraite_v[1:100]

```

Ainsi construite, notre fonction pourra prendre n'importe quelle autre chaîne de caractères en entrée. La preuve:

```{r}
pretraitement_f(donnees = "C'était un grand vaisseau taillé dans l'or massif. Ses mats touchaient l'azur, sur des mers inconnues.")


```

## Adapter la fonction aux besoins de l'utilisateur

Pour améliorer encore notre fonction, nous pouvons y ajouter des arguments qui permettront à l'utilisateur de produire un résultat conforme à ses besoins. Dans ses précédentes version, la fonction segmente le texte, impose les minuscules, supprime les ponctuations et les symboles, ainsi que les mots fonctionnels. L'utilisateur, à moins d'entrer dans le corps de la fonction et de la modifier de l'intérieur, ne peut choisir ses options de prétraitement.

Nous pouvons changer cela en ajouter à la fonction des arguments dans la parenthèse de `function()`. On indiquera des options par défaut à ces arguments, mais l'utilisateur pourra modifier ces paramètres lors de l'utilisation.

```{r}
pretraitement_f <- function(donnees, minuscules=TRUE, enlever_nombres=TRUE, enlever_ponctuation=TRUE, enlever_mots_fonctionnels=TRUE) {
  
  # Vérification que l'extension 'tm' est bien disponible
  if (!requireNamespace("tm", quietly = TRUE)) {
    stop("L'extension 'tm' est requis pour cette fonction.")
  }

  # Conversion en minuscules si demandé
  if (minuscules) {
    donnees <- tolower(donnees)
  }
  
  # Suppression de la ponctuation si demandé
  if (enlever_ponctuation) {
    donnees <- gsub(pattern = "[[:punct:]]+", replacement = " ", donnees, perl = TRUE)
  } 
  
  # Suppression des nombres si demandé
  if (enlever_nombres) {
    donnees <- gsub(pattern = "[0-9]+", replacement = " ", donnees, perl = TRUE)
  } 

  # Segmentation du texte en unités lexicales
  donnees <- strsplit(donnees, "\\s+") |> unlist()

  # Suppression des mots fonctionnels si demandé
  if (enlever_mots_fonctionnels) {
    donnees <- donnees[!donnees %in% tm::stopwords(kind ="fr")]
  } 

  # Avertissement si aucun mot n'est retenu après le prétraitement
  if (length(donnees) == 0) {
    warning("Le texte traité ne contient plus aucun mot après le prétraitement.")
  }

  return(donnees)
}

pretraitement_f(
  donnees = texte,
  minuscules = TRUE,
  enlever_ponctuation = TRUE,
  enlever_nombres = TRUE,
  enlever_mots_fonctionnels = TRUE)
```

## Fonction nommée VS fonction anonyme

La fonction de prétraitement ci-dessus porte un nom, `pretraitement_f()`. On peut aussi créer des fonctions anonymes, généralement moins complexes, qui ne sont pas destinées à être réutilisée hors d'un contexte donné.

Pour illustrer l'intérêt de ces fonctions anonymes, créons d'abord une fonction appelée `lancer_du_de_f`. Celle-ci, lorsqu'elle est exécutée, permet d'obtenir un nombre aléatoire compris entre 1 et 6. Le seul argument de la fonction est `nbre_fois=`, qui permet à l'utilisateur de préciser combien de lancers il souhaite faire. Par défaut, cet argument est de 1.

```{r}
lancer_du_de_f <- function(nbre_fois = 1) {
  
  # Création d'un vecteur contenant autant de NA que demandé dans nbre_fois=
  mes_lancers_v <- rep(NA, nbre_fois)
  
  # Boucle qui "lancera le dé" autant de fois que demandé, et placera le résultat dans le vecteur mes_lancers_v
  for(i in seq_along(mes_lancers_v)) {
    mes_lancers_v[i] <- sample.int(n=6, size = 1, replace = TRUE)
  }
  
  # Renvoi du résultat
  return(mes_lancers_v)
}

lancer_du_de_f()
```

Au lieu d'une boucle `for()`, on aurait pu, avec avantage, utiliser une fonction `sapply()` qui comprend elle-même trois arguments:

1\) un argument `X=`, l'objet sur lequel se fait l'itération;

2\) une fonction qui sera appliquée sur chaque élément de `X=`;

3\) les arguments éventuels de cette même fonction, séparés les uns des autres par une virgule.

C'est ici qu'une fonction anonyme peut être utile. Nous allons réécrire la fonction précédente en utilisant `sapply()` et en créant une fonction anonyme:

```{r}

lancer_du_de_f<- function(nbre_fois=1){
  
  sapply(X=1:nbre_fois, 
         FUN = function(x) sample.int(n=6, size = 1, replace = TRUE))
}

# Essayez
lancer_du_de_f()
lancer_du_de_f(25)

```

La fonction anonyme est créée au sein même de `sapply()` et ne pourra pas être réutilisée ailleurs. Elle ne remplit qu'une tâche, qui est d'indiquer à `sapply()` la fonction à utiliser sur les éléments du vecteur fourni en entrée. Cette fonction n'a pas de nom et n'a pas non plus besoin d'être encadrée par des accolades.

## Défi

Dans les ateliers précédents, nous avons utilisé une fonction nommée qui servait à installer et à activer des extensions:

```{r}
inst_pack_f <- function(x) {
  if(!x %in% rownames(installed.packages())) {
    install.packages(x)
    }
  require(x, character.only = TRUE)
}

extensions_v <- c("rbenchmark",
                  "data.table",
                  "pryr",
                  "ggplot2"
                  )

lapply(extensions_v, inst_pack_f)
```

Analysez cette fonction, `inst_pack_f`, et demandez-vous ce qu'impliquerait l'intégration des noms d'extension directement à l'intérieur de la parenthèse d'arguments de la fonction. Vous pouvez tenter de la modifier en conséquence!

## Pour aller plus loin

Sophie Baillargeon, [Fonctions en R](https://stt4230.rbind.io/programmation/fonctions_r/#fonction-anonyme)

Data Carpentry, "[Creating functions](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/)"

Garrett Grolemund, [*Hands-On Programming with R*](https://rstudio-education.github.io/hopr/), Beijing/Cambridge/Farnham/Köln/Sebastopol/Tokyo, O'Reilly, 2014.
