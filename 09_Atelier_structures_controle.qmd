---
title: "Atelier 9: structures de contrôle"
author: "Pascal Brissette (U. McGill)"
format: pdf
editor: visual
---

Dans l'Atelier 5, vous avez pu lire cette instruction:

```{r}
# Atelier 5
if(!"ouvrages" %in% ls()) {ouvrages <- readRDS("donnees/ouvrages.RDS")}

```

Dans l'Atelier 7, vous avez à nouveau pu voir une instruction ayant la même structure:

```{r}
if(!"rvest" %in% rownames(installed.packages())) {install.packages("rvest")}
```

On retrouve ce type d'instructions dans de nombreux langages de programmation. Elles sont très importantes et très puissantes, mais à quoi servent-elles?

Les commandes `if()`, `for()` et `while()` constituent des "structures de contrôle". On appelle ainsi des instructions qui indiquent à l'interpréteur à **quelle(s) condition(s)** **il doit exécuter** une ou une série de tâches, ou encore **à quelle(s) condition(s) il doit arrêter un processus itératif**. Les structures de contrôle se divisent en deux ensembles. Le premier est formé des structures conditionnelles, le second, des structures itératives.

Dans cet atelier, nous allons examiner ces deux types d'instructions et utiliser des exemples concrets pour vous aider à les maîtriser.

## Les structures conditionnelles

Tout d'abord, nous allons décomposer l'instruction du premier bloc et nous assurer de comprendre ses composantes.

Tout au coeur de l'instruction se trouve la fonction `ls()`. Exécutez cette fonction et voyez son résultat

```{r}
ls()
```

La fonction `ls()` retourne simplement la liste des objets qui se trouvent dans votre environnement de travail, ceux qui sont affichés dans le paneau supérieur droit de RStudio.

La structure conditionnelle `if()` dit à l'interpéteur que si "ouvrages" ne fait pas partie de la série des objets contenus dans l'environnement de travail, il doit l'importer.

Voici le détail:

| Partie de l'instruction | Traduction approximative et explication |
|--------------------|----------------------------------------------------|
| `if(…)` | "si est vrai ce qui se trouve dans la parenthèse..." |
| `!` | "...\[que\] n'est pas..." (opérateur de négation) |
| `"ouvrages"` | "...ouvrages..." (l'élément recherché) |
| `%in%` | "...dans le vecteur..." (opérateur d'inclusion) |
| `ls()` | "...tous les objets de l'environnement..." |
| `{...}` | "...alors exécute l'instruction..." (les accolades enserrent l'instruction à exécuter si la condition précédente est remplie) |
| `ouvrages <- readRDS("donnees/ouvrages.RDS")` | "...importation et assignation d'un objet à la variable `ouvrages`." (instruction) |

En résumé,

`if(!"ouvrages" %in% ls()) {ouvrages <- readRDS("donnees/ouvrages.RDS")}`

Veut dire: "si l'objet 'ouvrages' n'est pas déjà en mémoire dans l'environnement, importe-le".

Avant d'exécuter une structure de contrôle, vous pouvez tester ses composantes:

```{r}

# Est-ce que l'objet "ouvrages" est dans l'environnement de travail? La réponse sera TRUE ou FALSE
"ouvrages" %in% ls()


!"ouvrages" %in% ls() # Avec l'opérateur de négation


```

Comme l'instruction ci-dessus est insérée dans une structure conditionnelle `if()`, l'interpéteur s'attend à ce que vous fournissiez entre les accolades une instruction à suivre si le résultat du test est TRUE.

### Structure If()...else()

Dans l'exemple ci-dessus, la structure indique ce qu'il faut faire si la condition indiquée dans la parenthèse de `if()` est `TRUE`, mais qu'arrivera-t-il si le résultat du test est `FALSE`?

La réponse? Rien. La condition n'étant pas remplie et aucune autre option n'étant offerte, l'interpéteur ne fera rien.

Il pourrait cependant se trouver que vous souhaitiez indiquer à R qu'en cas de résultat négatif, il doit également faire quelque chose.

Construisons un tableau de données comprenant des noms d'auteures, des titres, des dates de publication et les genres littéraires associés.

```{r}
auteures_quebecoises <- data.frame(nom = c("Anne Hébert",
                                           "Nicole Brossard",
                                           "Joséphine Bacon",
                                           "Martine Delvaux"),
                                   oeuvre = c("Le tombeau des rois",
                                              "Le désert mauve",
                                              "Un thé dans la toundra",
                                              "Les filles en série"),
                                   annee = c(1953L, 1993L, 2013L, 2016L),
                                   genre = c("poésie", "roman", "poésie", "essai"))
auteures_quebecoises
```

On pourrait demander à R d'imprimer une phrase si, dans ce tableau, on trouve une certaine valeur.

```{r}
if(1953L %in% auteures_quebecoises$annee) {print("Oui, le tableau comporte bien une oeuvre publiée en 1953.")} # VRAI

if("Kamouraska" %in% auteures_quebecoises$oeuvre) {print("Oui, Kamouraska fait bien partie des oeuvres du tableau.")} # FAUX

```

Les choses se déroulent bien comme nous l'avions prévu: la condition du premier test étant remplie (`TRUE`), R exécute l'instruction contenue dans les accolades qui suivent. Le résultat du test de la deuxième instruction étant `FALSE`, R ne fait rien.

Il serait bien entendu préférable de pouvoir ajouter une clause à notre test et dire à R ce qu'il doit faire si la réponse est `FALSE`. C'est ce qu'on fera en ajoutant une instruction `else()`:

```{r}
if("Kamouraska" %in% auteures_quebecoises$oeuvre) {
  print("Oui, Kamouraska fait bien partie des oeuvres du tableau.")
  } else {
    print("Non, Kamouraska ne fait pas partie des oeuvres du tableau.")
    }
```

### Structures conditionnelles imbriquées

Vous vous retrouverez souvent dans des situations où vous souhaiterez que des instructions soient exécutées seulement si plusieurs conditions sont remplies ou ne le sont pas. Vous pourrez alors imbriquer des structures conditionnelles. La forme générale de cette structure est la suivante:

```{r}
# if( <test_1> ) {

#   <instructions> # exécutées si le résultat du test est TRUE

#     } else if( <test_2> ) {

#     <instructions> # exécutées si résultat de test_1 est FALSE et résultat de test_2 est TRUE

#         } else {

#           <instructions> #exécutées si résultats de test_1 et test_2 sont FALSE

#             }

```

Nous allons tirer partie de cette structure imbriquée pour ajouter une auteure à notre tableau. Nous allons d'abord demander à R si le livre *Folle* de Nelly Arcan se trouve dans le tableau (vecteur `auteures_quebecoises$oeuvre`). S'il s'y trouve, il devra renvoyer la phrase "Oui, l'ouvrage *Folle* de Nelly Arcan fait partie du tableau". S'il n'y est pas, il passera au deuxième test, qui consiste à vérifier si l'auteure Nelly Arcan est l'une des auteures du tableau (vecteur `auteures_quebecoises$nom`). Si le test est positif, R devra renvoyer la phrase "Le titre *Folle* ne fait pas partie du tableau, mais l'auteure s'y trouve avec un autre titre". Si le test est négatif, il devra ajouter le titre *Folle* et les éléments apparentés dans le tableau.

```{r}
if("Folle" %in% auteures_quebecoises$oeuvre) {
  print("Oui, l'ouvrage Folle de Nelly Arcan fait partie du tableau")
} else if ("Nelly Arcan" %in% auteures_quebecoises$nom) {
  print(
    "Le titre Folle ne fait pas partie du tableau, mais l'auteure s'y trouve avec un autre titre"
  )
} else {
  auteures_quebecoises <- rbind(auteures_quebecoises,
                                list("Nelly Arcan", "Folle", 2004L, "roman"))
  print(
    "Le titre Folle et l'auteure Nelly Arcan ne faisaient pas partie du tableau. Nous avons fait cet ajout"
  )
}
```

Si vous exécutez les instructions ci-dessus une première fois, vous recevrez le message indiquant que le titre et l'auteure ne faisaient pas partie du tableau, et qu'ils y ont été ajoutés. Si vous exécutez à nouveau le bloc d'instructions, vous recevrez un autre message parce que le titre a été ajouté. Essayez!

Utilisons un autre exemple de la même structure conditionnelle, et profitons-en pour ajouter des auteures à notre tableau.

Nous allons demander à R de vérifier si, dans notre tableau, se trouvent des oeuvres publiées avant 1950. Dans le cas contraire, il devra ajouter trois lignes au tableau. Avant de faire cette opération, nous allons ordonner le tableau de manière chronologique, en utilisant le vecteur `auteures_quebecoises$annee` comme point d'entrée:

```{r}
# Ordonner le tableau en fonction de la date de publication des oeuvres
auteures_quebecoises <- auteures_quebecoises[order(auteures_quebecoises$annee),]

# Comme condition, demandons maintenant à R si le premier élément du vecteur annee est égal ou supérieur à 1950. Si le résultat est TRUE, cela veut dire qu'aucune oeuvre antérieure à 1950 ne figure dans le tableau. Il devra alors ajouter trois entrées.
if(auteures_quebecoises$annee[1] >= 1950) {
  auteures_quebecoises <- rbind(list("Elisabeth Bégon", "Lettres au cher fils", 1748L, "lettres"),
                                list("Blanche Lamontagne-Beauregard", "Visions gaspésiennes", 1913L, "poésie"),
                                list("Laure Conan", "Angéline de Monbrun", 1882L, "roman"),
                                auteures_quebecoises)
  print("Trois auteures, dont les oeuvres ont été publiées avant 1950, ont été ajoutées au tableau.")
} else {
  print("Le tableau comporte déjà au moins une oeuvres antérieures à 1950.")
}
```

Vous pouvez observer le résultat en utilisant une fonction que vous connaissez maintenant très bien, `View()`:

```{r}
View(auteures_quebecoises)

# Pour obtenir une présentation chronologique des titres, vous pouvez recycler l'instruction utilisée ci-dessus:

View(auteures_quebecoises[order(auteures_quebecoises$annee),])
```

## Les boucles

Le test que nous avons fait ci-dessus consistait à vérifier si le premier élément de la colonne `auteures_quebecoises$annee`, préalablement ordonnée du plus petit au plus grand nombre entier, répondait à une condition spécifique. Le test ne portait que sur cet élément en particulier. Il y a cependant des cas où nous souhaitons que chaque élément de chaque ligne fasse l'objet d'un test. Prenons un exemple pour illustrer ce type de situation.

Supposons que nous demandions à R d'ajouter à notre tableau une colonne "periode" fondée sur la valeur indiquée dans une autre colonne, celle des années de publication. Une simple instruction `if()` pourra-t-elle nous être utile? La réponse est non, car l'interpréteur n'évaluera que la première valeur trouvée, soit celle indiquée dans `auteures_quebecoises$annee[1]`. Il insérera alors dans la nouvelle colonne `auteures_quebecoises$periode` la même valeur pour chacune des lignes. Ce n'est pas ce que nous voulons. Nous voudrions qu'il fasse passer le test à chacune des valeurs de la colonne `auteures_quebecoises$annee` et, si le résultat d'un test donné est `FALSE`, qu'il exécute une ligne de commande dont le résultat sera écrit dans la colonne `auteures_quebecoises$periode`.

Pour faire une telle chose, nous devrons recourir à une boucle, plus exactement à une boucle `for()`. Observez la construction des lignes d'instructions dans le bloc ci-dessous:

```{r}
for(i in 1:nrow(auteures_quebecoises)) {
  if(auteures_quebecoises$annee[i] > 1999) {
    auteures_quebecoises$periode[i] <- "XXIe siècle"
    } else if(auteures_quebecoises$annee[i] %in% 1899:2000) {
      auteures_quebecoises$periode[i] <- "XXe siècle"
      } else if(auteures_quebecoises$annee[i] %in% 1799:1900) {
        auteures_quebecoises$periode[i] <- "XIXe siècle"
        } else {
          auteures_quebecoises$periode[i] <- "XVIIIe siècle"
        }
  }
```

### La boucle `for()`

La boucle `for()` permet de répéter un nombre de fois déterminé une séquence d'instructions sur un objet récursif.

La structure de la boucle se présente comme suit:

`for( <chaque élément de ... à ...> ) { <instructions(s)> }`

Dans le bloc d'instructions ci-dessus, on a demandé à l'interpréteur de répéter la structure conditionnelle `if() … else()` contenue dans les accolades autant de fois qu'il y a de lignes dans le tableau `auteures_quebecoises`. On a utilisé la variable `i` pour désigner chacun des éléments de la boucle (par convention, `i` renvoyant à l'argument des lignes dans l'indexation d'un tableau), mais on aurait pu utiliser n'importe quelle autre chaîne de caractères, voire un mot comme "occurrence". Dans chaque itération de la boucle, `i` a pris un numéro de ligne, de 1 à `nrow(auteures_quebecoises)`, donc de 1 à 8. Ainsi, la première fois que l'interpréteur a passé à travers le bloc d'instructions, le `i` valait 1 et l'élément du tableau ainsi indicé a fait l'objet des tests de la structure `if()…else()`. Arrivé au bout des instructions, l'interpréteur a recommencé et a attribué la valeur 2 à la variable `i`, et ainsi de suite jusqu'à 8. Dans cette structure, on dit d'emblée à R, dans la parenthèse, combien de fois il doit itérer.

Pour dire les choses autrement, la boucle `for()` a vérifier chacune des valeurs de la colonne auteures_quebecoises\$annee et, selon le résultat des tests introduits par l'instruction `if() ... else()`, a inscrit ce que nous lui avions demandé dans au croisement des lignes 1 à 8 et de la colonne `auteures_quebecoises$periode`.

### La boucle `while()`

Les boucles `while()` ont la même structure que les boucles `for()`, mais au lieu d'exécuter une commande un nombre de fois déterminé d'emblée, elles les exécutent tant et aussi longtemps qu'une certaine condition n'est pas remplie. Cette caractéristique les rend à la fois plus souples et plus dangereuses. Plus souples, parce qu'on n'est pas forcé de leur fournir un nombre prédéterminé d'itérations. Plus dangereuses, parce que si cette condition, pour quelque raison que ce soit, n'est pas remplie, la boucle se poursuit indéfiniment et il faudra y mettre un terme en utilisant un levier externe (fermeture forcée du logiciel, etc.).

Ce type de structure a un intérêt particulier dans un programme interactif où une réponse donnée à une question peut entrainer l'exécution automatique d'une commande. Supposons par exemple qu'on souhaite inviter les internautes à ajouter des notices à notre tableau des auteures québécoises. On pourrait demander à nos internautes imaginaires de répondre à une série de questions correspondant aux valeurs du tableau, emmagasiner ces valeurs dans des objets, les assembler dans une liste, puis joindre celle-ci à notre tableau. Les questions apparaitront dans la console lorsque vous exécuterez le code ci-dessous.

#### Exemple 1

```{r}
# Préparez-vous à ajouter des notices à notre tableau!

# Première instruction
reponse <- tolower(
  readline(prompt = "Souhaites-tu ajouter une notice au tableau des auteures québécoises? (oui/non) ")
)

# Deuxième instruction
if (reponse == tolower("oui")) {
  while (!reponse == tolower("non")) {
    auteure_temp <- readline(prompt = "Écris le nom d'une auteure (ex. 'Elisabeth Begon'): ")
    oeuvre_temp <- readline(prompt = "Donne le titre de l'une de ses oeuvres: ")
    annee_temp <- readline(prompt = "Indique l'année de publication de cette oeuvre:  ")
    genre_temp <- readline(prompt = "Précise le genre de cette oeuvre (genres disponibles: roman, poésie, théâtre, essai, lettres, autre) :  ")
    periode_temp <- readline(prompt = "Indique la période de cette oeuvre (exemple: 'XXIe siècle'):  ")
    une_notice <- list(auteure_temp,
                       oeuvre_temp,
                       annee_temp,
                       genre_temp,
                       periode_temp)   # les différentes réponses sont rassemblées dans une liste
    auteures_quebecoises <- rbind(auteures_quebecoises, une_notice)
    auteures_quebecoises <- auteures_quebecoises[order(auteures_quebecoises$annee),]
    reponse <- tolower(
      readline(prompt = "Merci pour l'ajout de cette notice! Souhaites-tu en ajouter une autre? (oui/non) ")
    )
  }
} else {
  print("Merci tout de même d'avoir bien voulu répondre à cette question!")
}

```

Le bloc d'instructions ci-dessus contient deux principales parties.

1\) Il y a tout d'abord une instruction tirant profit de la fonction `readline()` pour poser une question (dans la console), dont la réponse doit être "oui" ou "non". Si jamais l'internaute écrit "Non", avec une majuscule, plutôt que les trois caractères minuscules attendus, la fonction `tolower()` transformera la chaîne de caractères en lettres minuscules. La réponse à cette question est emmagasinée dans une variable, `reponse`.

2\) La commande `if()` ouvre ensuite une alternative. La condition insérée dans la parenthèse de `if( )` est celle d'une équivalence entre l'objet `reponse` et les trois caractères "oui". Si cette condition est `TRUE`, alors R enchaînera avec les instructions insérées dans les accolades.

Si la réponse à la question a été "non", R descendra immédiatement à `else{…}` et comprendra qu'il doit renvoyer la phrase "Merci...".

Dans les instructions insérées dans les accolades, il y a une boucle `while()`. Celle-ci indique, dans la parenthèse, à quelle condition le processus itératif doit être arrêté. Cette condition peut se lire comme suit: "tant et aussi longtemps que la réponse à la question insérée à la fin des instructions n'est pas"non", continue de poser des questions et d'ajouter des lignes au tableau. Sitôt que la réponse à la question de la boucle sera "non", la boucle sera rompue et les itérations s'arrêteront.

## Défi

1.  Ajoutez une colonne au tableau de données `auteures_quebecoises` appelée `type`. Les modalités insérées dans cette colonne seront fondées sur celles de la colonne `genre`.

-   Si la modalité au croisement de auteures_quebecoises\[`i`, "genre"\] est "lettres", "roman" ou "essai", alors celle qui doit être inscrite dans la colonne `type`, pour la même ligne, doit être "prose";

-   Si la modalité au croisement de auteures_quebecoises\[`i`, "genre"\] est "poésie", alors celle qui doit être inscrite dans la colonne `type`, pour la même ligne, doit être "vers".

2.  Dans l'Atelier 7 sur le grattage de sites internet, nous avons utilisé une boucle `while()` pour lire et importer chacun des 11 paragraphes de l'article ["Premier ministre du Québec"](https://fr.wikipedia.org/wiki/Premier_ministre_du_Qu%C3%A9bec) de la page Wikipédia. Nous reproduisons ci-dessous le bloc de code. Les instructions sont précédées d'un croisillon et d'un chiffre. Expliquez chacune de ces six instructions.

    ```{r}
    # Se présenter et vérifier l'accessibilité de la page
    session <- bow("https://fr.wikipedia.org/wiki/Premier_ministre_du_Qu%C3%A9bec",
                   user_agent = "Pascal Brissette, U. McGill, pascal.brissette@mcgill.ca")

    # On lit la page
    lecture_page <- scrape(session)

    # On crée une liste comprenant 11 éléments
    description <- vector(11, mode = "list")

    # On détermine le numéro initial de l'élément p
    i = 2

    # On crée la boucle
    while (i < 13) {
      description[[i - 1]] <- html_element(
        lecture_page,
        xpath = paste0(
          "/html/body/div[2]/div/div[3]/main/div[3]/div[3]/div[1]/p[",
          i,
          "]"
        )
      ) |> html_text2()
      i = i + 1
    }

    description
    ```

## Pour aller plus loin

Sophie Baillargeon, [Site du cours STT-4230](https://stt4230.rbind.io/programmation/struct_controle_r/), section sur les structures de contrôle.

[Article de R-Bloggers](https://www.r-bloggers.com/) sur les structures de contrôle (utiliser l'outil de recherche pour trouver les articles d'intérêt.
